<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スケジュールチェック</title>
    <!-- Favicon はJavaScriptで動的に設定 -->
    <style>
        /* 基本スタイル */
        body { font-family: sans-serif; margin: 15px; background-color: #f8f9fa; }
        .schedule-container { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 100%; }
        h1 { font-size: 1.5em; margin-bottom: 15px; }

        /* 操作コントロール */
        .controls { display: flex; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 8px; }
        .controls button, .controls select, .controls input[type="number"] { padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; background-color: #fff; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, opacity 0.2s; font-size: 0.9em; }
        .controls button:hover { background-color: #eee; }
        .controls button.primary { background-color: #007bff; color: white; border-color: #007bff; }
        .controls button.primary:hover { background-color: #0056b3; }
        .controls button.info { background-color: #17a2b8; color: white; border-color: #17a2b8; }
        .controls button.info:hover { background-color: #117a8b; }
        .controls button.success { background-color: #28a745; color: white; border-color: #28a745; }
        .controls button.success:hover { background-color: #218838; }
        .controls span#monthYear { font-size: 1.1em; font-weight: bold; margin: 0 8px; }
        .controls input[type="number"] { width: 60px; }

        /* ファイル操作系コントロール */
        .file-controls { margin-left: auto; display: flex; align-items: center; gap: 8px; }
        #unsavedChanges { color: orange; font-weight: bold; margin-right: 10px; }
        #fileInput { display: none; }

        /* テーブル全体のスタイル */
        #scheduleTable { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; border: 1px solid #ccc; }
        #table-wrapper { max-height: 65vh; overflow-y: auto; border-bottom: 1px solid #ccc; }

        /* テーブルヘッダー (thead) */
        #scheduleTable thead th {
            background-color: #f2f2f2; font-weight: bold; position: sticky; top: 0; z-index: 2;
            vertical-align: middle; padding: 4px; border: 1px solid #ddd; font-size: 0.85em;
            line-height: 1.2; text-align: center;
        }
        #scheduleTable thead th:first-child { /* メンバー列ヘッダー */
            width: 120px; background-color: #e9ecef; z-index: 3;
            text-align: left; padding-left: 10px; vertical-align: middle;
        }
        #scheduleTable thead th.date-header { font-size: 0.8em; }
        #scheduleTable thead th .day-number { display: block; font-size: 1.1em; line-height: 1; }
        #scheduleTable thead th .day-of-week { display: block; font-size: 0.9em; color: #555; }

        /* テーブルボディ (tbody) */
        #scheduleTable tbody th, #scheduleTable tbody td {
            border: 1px solid #ddd; padding: 0; text-align: center; white-space: normal;
            overflow: hidden; text-overflow: ellipsis; font-size: 0.85em;
            vertical-align: middle; cursor: default;
        }
        #scheduleTable tbody th { /* メンバー名セル */
            background-color: #f8f9fa; font-weight: normal; text-align: left;
            z-index: 1; width: 120px; border-right: 1px solid #ccc;
            padding-left: 10px; display: flex; align-items: center;
        }
        #scheduleTable tbody th[contenteditable="true"] { cursor: text; background-color: #fff; }
        #scheduleTable tbody th[contenteditable="true"]:focus { outline: 2px solid #007bff; background-color: #eef; }
        #scheduleTable tbody td { /* 日付データセル */
            background-color: #fff; cursor: pointer; transition: background-color 0.1s ease-in-out;
        }

        /* 曜日・祝日による背景色 */
        .saturday { background-color: #e3f2fd !important; }
        .sunday { background-color: #ffebee !important; }
        .holiday { background-color: #fff3e0 !important; }
        #scheduleTable tbody tr td.saturday-cell { background-color: #f0f8ff; }
        #scheduleTable tbody tr td.sunday-cell { background-color: #fff7f7; }
        #scheduleTable tbody tr td.holiday-cell { background-color: #fffaf0; }

        /* 今日の列のハイライト */
        #scheduleTable th.today-column, #scheduleTable td.today-column {
             border-left: 2px solid red !important; border-right: 2px solid red !important;
             background-color: #fffde7 !important;
        }
        #scheduleTable thead th.today-column { border-top: 2px solid red !important; }
        #scheduleTable tbody tr:last-child td.today-column { border-bottom: 2px solid red !important; }

        /* クリックされたセルのスタイル */
        #scheduleTable tbody td.clicked-cell { background-color: #007bff !important; }
        #scheduleTable td.today-column.clicked-cell { background-color: #007bff !important; }

        /* 列を非表示にするスタイル */
        .hidden-column { display: none; }

        /* 読み込み中・エラーメッセージ */
        .loading { font-style: italic; color: #888; text-align: center; padding: 20px; }
        #error-message { color: red; margin-top: 10px; min-height: 1.2em; }

        /* 非活性ボタンのスタイル */
        .controls button:disabled { background-color: #e9ecef; color: #6c757d; border-color: #ced4da; cursor: not-allowed; opacity: 0.65; }
        .controls button.success:disabled { background-color: #a3d9af; border-color: #a3d9af; color: #6c757d; }

        /* パス表示エリアのスタイル */
        #savedPathContainer { margin-top: 10px; padding: 8px; background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9em; display: flex; align-items: center; gap: 8px; }
        #savedPathContainer button { padding: 2px 6px; font-size: 0.8em; }

        /* 設定画面のスタイル */
        #settingsContainer { margin-top: 15px; padding: 15px; border: 1px dashed #ccc; background-color: #f9f9f9; border-radius: 4px; }
        #settingsContainer h4 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em;}
        #settingsContainer label { margin-right: 5px; font-size: 0.9em; }
        #settingsContainer input[type="text"] { padding: 4px 6px; border: 1px solid #ccc; border-radius: 3px; width: calc(100% - 180px); min-width: 200px; font-size: 0.9em; }
        #settingsContainer button { margin-left: 5px; padding: 4px 8px; font-size: 0.9em; }
        #openSettingsButton { margin-left: 15px; background-color: #6c757d; color: white; border-color: #6c757d; }
        #openSettingsButton:hover { background-color: #5a6268; }
    </style>
</head>
<body>

<h1>スケジュールチェック</h1>

<div class="schedule-container">
    <!-- 操作ボタン群 -->
    <div class="controls">
        <button id="prevMonth">&lt; 前月</button>
        <span id="monthYear">読み込み中...</span>
        <button id="nextMonth">次月 &gt;</button>
        <input type="number" id="yearInput" placeholder="年">
        <input type="number" id="monthInput" placeholder="月" min="1" max="12">
        <button id="moveButton">移動</button>
        <button id="todayButton">今日へ</button>
        <button id="addMemberButton" class="primary">メンバー追加</button>
        <button id="openSettingsButton">設定</button>
        <div class="file-controls">
            <span id="unsavedChanges" style="display: none;">▲ 未保存の変更があります</span>
            <button id="loadButton" class="info">JSON読込</button>
            <input type="file" id="fileInput" accept=".json">
            <button id="saveButton" class="success" disabled>JSON保存</button>
        </div>
    </div>

    <!-- 設定画面エリア (初期状態は非表示) -->
    <div id="settingsContainer" style="display: none;">
        <h4>設定</h4>
        <label for="savePathInput">推奨保存先パス:</label>
        <input type="text" id="savePathInput" placeholder="例: C:\Users\YourName\Documents\Schedules">
        <button id="applySettingsButton">適用</button>
        <button id="closeSettingsButton">閉じる</button>
    </div>

    <!-- スケジュールテーブル表示エリア -->
    <div id="table-wrapper">
        <table id="scheduleTable">
            <thead><tr id="headerRow"><th>メンバー</th></tr></thead>
            <tbody id="scheduleBody"><tr><td colspan="32" class="loading">データを読み込んでいます...</td></tr></tbody>
        </table>
    </div>

    <!-- エラーメッセージ表示エリア -->
    <p id="error-message"></p>

    <!-- 推奨保存先パス表示エリア (初期状態は非表示) -->
    <div id="savedPathContainer" style="display: none;">
        <span>推奨保存先: </span>
        <span id="savedPathDisplay"></span>
        <button id="copyPathButton">パスをコピー</button>
    </div>

</div>

<script>
    // --- 定数 ---
    const MAX_DAYS = 31; // カレンダーで表示する最大日数
    const MIN_CELL_HEIGHT = 30; // セルの最低高さ (px)
    const RESIZE_DEBOUNCE_TIME = 150; // ウィンドウリサイズ時の再計算遅延時間 (ms)
    const WEEK_DAY_SHORT_NAMES = ["日", "月", "火", "水", "木", "金", "土"]; // 曜日の略称

    // --- DOM要素取得 ---
    // 頻繁にアクセスするDOM要素を変数に格納
    const scheduleBody = document.getElementById('scheduleBody');
    const headerRow = document.getElementById('headerRow');
    const monthYearElement = document.getElementById('monthYear');
    const prevMonthButton = document.getElementById('prevMonth');
    const nextMonthButton = document.getElementById('nextMonth');
    const yearInput = document.getElementById('yearInput');
    const monthInput = document.getElementById('monthInput');
    const moveButton = document.getElementById('moveButton');
    const todayButton = document.getElementById('todayButton');
    const addMemberButton = document.getElementById('addMemberButton');
    const loadButton = document.getElementById('loadButton');
    const fileInput = document.getElementById('fileInput');
    const saveButton = document.getElementById('saveButton');
    const unsavedChangesElement = document.getElementById('unsavedChanges');
    const errorMessageElement = document.getElementById('error-message');
    const tableWrapper = document.getElementById('table-wrapper');
    const scheduleTable = document.getElementById('scheduleTable');
    // 設定関連
    const settingsContainer = document.getElementById('settingsContainer');
    const savePathInput = document.getElementById('savePathInput');
    const applySettingsButton = document.getElementById('applySettingsButton');
    const closeSettingsButton = document.getElementById('closeSettingsButton');
    const openSettingsButton = document.getElementById('openSettingsButton');
    // パス表示関連
    const savedPathContainer = document.getElementById('savedPathContainer');
    const savedPathDisplay = document.getElementById('savedPathDisplay');
    const copyPathButton = document.getElementById('copyPathButton');

    // --- グローバル変数 ---
    let currentDate = new Date();      // 現在カレンダーが表示している年月
    let holidaysData = {};           // 祝日データ ({"YYYY-MM-DD": "祝日名"})
    let members = [];                // メンバー名のリスト (表示順)
    let scheduleData = {};           // スケジュールデータ ({"メンバー名": {"YYYY-MM-DD": true}})
    let hasUnsavedChanges = false;   // 未保存の変更があるかを示すフラグ
    let currentRecommendedSavePath = ""; // 推奨保存先パス (設定画面用)
    let resizeTimeout;               // ウィンドウリサイズ時の処理遅延用タイマーID

    // --- 関数定義 ---

    /**
     * 祝日データを内閣府提供のAPI互換JSONから非同期で取得する。
     * @returns {Promise<boolean>} データ取得の成否。
     */
    async function fetchHolidays() {
        const apiUrl = 'https://holidays-jp.github.io/api/v1/date.json';
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error(`APIエラー (ステータス: ${response.status})`);
            holidaysData = await response.json();
            errorMessageElement.textContent = ''; // エラーメッセージクリア
            console.info("祝日データ取得成功");
            return true;
        } catch (error) {
            console.error('祝日データの取得に失敗しました:', error);
            errorMessageElement.textContent = `エラー: 祝日データの取得に失敗しました。(${error.message})`;
            holidaysData = {}; // 取得失敗時は空データ
            return false;
        }
    }

    /**
     * 年月日から 'YYYY-MM-DD' 形式の文字列を生成する。
     * @param {number} year - 年。
     * @param {number} month - 月 (0-11)。
     * @param {number} day - 日 (1-31)。
     * @returns {string} 'YYYY-MM-DD' 形式の文字列。
     */
    function formatDate(year, month, day) {
        return `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    }

    /**
     * テーブルの行の高さを調整し、日付セルが正方形に近づくようにする。
     * 常に31日分の列が存在する前提で計算し、不要な列はCSSで非表示にする。
     */
    function adjustRowHeights() {
        if (!scheduleTable || !headerRow || scheduleBody.children.length === 0) return; // 必要な要素がなければ終了
        const memberNameHeader = headerRow.querySelector('th:first-child');
        if (!memberNameHeader) return; // メンバーヘッダーがなければ終了

        const memberNameWidth = memberNameHeader.offsetWidth;
        const dateColumnCount = MAX_DAYS; // 列数は常に31で計算
        const tableVisibleWidth = scheduleTable.clientWidth;
        const availableWidthForDates = tableVisibleWidth - memberNameWidth;
        let cellWidth = Math.max(10, availableWidthForDates / dateColumnCount); // 幅計算 (最低10px)

        const calculatedHeight = Math.max(cellWidth, MIN_CELL_HEIGHT); // 高さ計算 (最低MIN_CELL_HEIGHT)
        const finalHeight = `${calculatedHeight}px`;

        // ヘッダーとボディの全セルの高さを設定
        headerRow.querySelectorAll('th').forEach(th => { th.style.height = finalHeight; });
        Array.from(scheduleBody.children).forEach(row => {
            row.querySelectorAll('th, td').forEach(cell => {
                cell.style.height = finalHeight;
                if (cell.tagName === 'TD') { cell.style.lineHeight = finalHeight; } // TDはline-heightも合わせる
            });
        });
    }

    /**
     * 指定された年月のスケジュール表を描画（または再描画）する。
     * 常に31日分の列を描画し、存在しない日付の列は非表示にする。
     * @param {number} year - 表示する年。
     * @param {number} month - 表示する月 (0-11)。
     */
    function generateSchedule(year, month) {
        console.info(`スケジュール描画開始: ${year}年${month + 1}月`);
        // --- ヘッダー部分の更新 ---
        headerRow.innerHTML = '<th>メンバー</th>'; // ヘッダー初期化
        monthYearElement.textContent = `${year}年 ${month + 1}月`;
        yearInput.value = year;
        monthInput.value = month + 1;
        const daysInMonth = new Date(year, month + 1, 0).getDate(); // 表示月の日数
        const today = new Date();
        const todayYear = today.getFullYear();
        const todayMonth = today.getMonth();
        const todayDate = today.getDate();

        // --- ヘッダーセル生成 (常に1日からMAX_DAYSまで) ---
        for (let day = 1; day <= MAX_DAYS; day++) {
            const th = document.createElement('th');
            if (day <= daysInMonth) { // 月の日付が存在する場合
                const currentDay = new Date(year, month, day);
                const dayOfWeek = currentDay.getDay();
                const dateStr = formatDate(year, month, day);
                th.classList.add('date-header');
                th.innerHTML = `<span class="day-number">${day}</span><span class="day-of-week">(${WEEK_DAY_SHORT_NAMES[dayOfWeek]})</span>`;
                // 曜日・祝日クラス設定
                if (holidaysData[dateStr]) { th.classList.add('holiday'); th.title = holidaysData[dateStr]; }
                else if (dayOfWeek === 0) { th.classList.add('sunday'); }
                else if (dayOfWeek === 6) { th.classList.add('saturday'); }
                // 今日の日付なら today-column クラスを追加
                if (year === todayYear && month === todayMonth && day === todayDate) {
                    th.classList.add('today-column');
                }
            } else { // 月の日付が存在しない場合
                th.classList.add('hidden-column'); // 非表示クラス
            }
            headerRow.appendChild(th);
        }

        // --- ボディ部分の生成 ---
        scheduleBody.innerHTML = ''; // ボディクリア
        members.forEach(memberName => {
            // 各メンバーについて行要素を作成・追加 (31日分のセルを持つ)
            const memberRow = createMemberRowElement(memberName, year, month, daysInMonth);
            scheduleBody.appendChild(memberRow);
        });

        // --- 今日のボディ列ハイライト ---
        if (year === todayYear && month === todayMonth) { // 今月を表示している場合のみ
            const todayCellIndex = todayDate - 1; // 0始まりインデックス
            Array.from(scheduleBody.querySelectorAll('tr')).forEach(row => {
                const cellsInRow = row.querySelectorAll('td'); // 行内の全td要素
                // インデックスが有効範囲内か確認 (常にMAX_DAYS=31列ある)
                if (todayCellIndex >= 0 && cellsInRow.length > todayCellIndex) {
                     const bodyCell = cellsInRow[todayCellIndex];
                     if (bodyCell) { bodyCell.classList.add('today-column'); }
                }
            });
        }

        // --- 高さ調整 ---
        requestAnimationFrame(adjustRowHeights); // DOM更新後に高さを調整
        console.info(`スケジュール描画完了: ${year}年${month + 1}月`);
    }

    /**
     * メンバー1人分の行要素（<tr>）を作成する。
     * 常に31日分のセルを持つ行を生成し、不要な日付セルは非表示クラスを付与する。
     * @param {string} memberName - メンバー名。
     * @param {number} year - 年。
     * @param {number} month - 月 (0-11)。
     * @param {number} daysInMonth - その月の日数。
     * @returns {HTMLTableRowElement} 作成された行要素 (<tr>)。
     */
    function createMemberRowElement(memberName, year, month, daysInMonth) {
        const row = document.createElement('tr');
        // メンバー名セル (th) を作成・設定
        const th = document.createElement('th');
        th.setAttribute('contenteditable', 'true');
        th.textContent = memberName;
        th.addEventListener('input', handleMemberNameInput);
        th.addEventListener('keypress', handleMemberNameEnter);
        th.addEventListener('keydown', handleMemberNameBackspace);
        row.appendChild(th);

        // 日付セル (td) を生成 (常に1日からMAX_DAYSまで)
        for (let day = 1; day <= MAX_DAYS; day++) {
            const td = document.createElement('td');
            if (day <= daysInMonth) { // 月の日付が存在する場合
                const dateStr = formatDate(year, month, day);
                td.dataset.member = memberName; // データ属性設定
                td.dataset.date = dateStr;
                // 曜日・祝日クラス設定
                const currentDay = new Date(year, month, day);
                const dayOfWeek = currentDay.getDay();
                if (holidaysData[dateStr]) { td.classList.add('holiday-cell'); }
                else if (dayOfWeek === 0) { td.classList.add('sunday-cell'); }
                else if (dayOfWeek === 6) { td.classList.add('saturday-cell'); }
                // スケジュールデータに基づくクリック状態復元
                if (scheduleData[memberName] && scheduleData[memberName][dateStr]) {
                    td.classList.add('clicked-cell');
                }
            } else { // 月の日付が存在しない場合
                td.classList.add('hidden-column'); // 非表示クラス
            }
            row.appendChild(td);
        }
        return row;
    }

    /**
     * メンバー名セルが編集されたときの処理。
     * 未保存フラグを立て、scheduleDataと関連するtdのdatasetを更新する。
     * @param {Event} event - inputイベントオブジェクト。
     */
    function handleMemberNameInput(event) {
        setUnsavedChanges(true); // 未保存フラグON
        const cell = event.target; // 編集されたセル(th)
        const currentRow = cell.closest('tr');
        const currentName = cell.textContent.trim(); // 新しい名前
        const tds = currentRow.querySelectorAll('td:not(.hidden-column)'); // 表示されている日付セル
        const originalName = tds.length > 0 ? tds[0].dataset.member : ''; // 元の名前

        // scheduleDataのキー更新処理
        if (originalName && originalName !== currentName && scheduleData[originalName]) {
            if (!scheduleData[currentName]) {
                scheduleData[currentName] = scheduleData[originalName];
                delete scheduleData[originalName];
            } else {
                console.warn(`メンバー名変更警告: "${currentName}" は既に存在します。"${originalName}" のデータは失われます。`);
                delete scheduleData[originalName]; // 古いデータ削除
            }
        }
        // 表示されている日付セルのdataset.memberを更新
        tds.forEach(td => { td.dataset.member = currentName; });
    }

    /**
     * 新しいメンバー行（空行）をテーブルの末尾に追加する。
     * @param {boolean} [setUnsaved=true] - 追加時に未保存フラグを立てるか。
     */
    function addMemberRow(setUnsaved = true) {
        hideSavedPathInfo();
        const currentYear = currentDate.getFullYear();
        const currentMonth = currentDate.getMonth();
        const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
        const newRow = createMemberRowElement("", currentYear, currentMonth, daysInMonth); // 空行作成
        scheduleBody.appendChild(newRow);

        // ★ generateScheduleでまとめて処理するため、ここでの今日のハイライト処理は不要 ★

        requestAnimationFrame(adjustRowHeights); // 高さ調整
        tableWrapper.scrollTop = tableWrapper.scrollHeight; // 最下部へスクロール
        const newMemberCell = newRow.querySelector('th[contenteditable="true"]');
        if (newMemberCell) newMemberCell.focus(); // 新規セルのフォーカス
        if (setUnsaved) setUnsavedChanges(true);
        console.info("新しいメンバー行を追加しました");
    }

    /**
     * メンバー名セルでEnterキーが押されたときの処理。
     * 次の行へフォーカス移動、または最終行なら新規行追加。
     * @param {KeyboardEvent} event - keypressイベントオブジェクト。
     */
    function handleMemberNameEnter(event) {
        if (event.key === 'Enter') {
            event.preventDefault(); // 改行防止
            const cell = event.target;
            const currentName = cell.textContent.trim();
            if (currentName && !scheduleData[currentName]) { scheduleData[currentName] = {}; } // データ準備
            const currentRow = cell.closest('tr');
            const rows = Array.from(scheduleBody.children);
            const currentIndex = rows.indexOf(currentRow);
            if (currentIndex === rows.length - 1) { // 最終行の場合
                addMemberRow(); // 新規行追加
            } else { // 最終行でない場合
                const nextRow = rows[currentIndex + 1];
                const nextMemberCell = nextRow?.querySelector('th[contenteditable="true"]');
                if (nextMemberCell) nextMemberCell.focus(); // 次の行へフォーカス
            }
        }
    }

    /**
     * メンバー名セルが空の状態でBackspaceキーが押されたときの処理。
     * 行を削除し、適切なセルへフォーカスを移動する。
     * @param {KeyboardEvent} event - keydownイベントオブジェクト。
     */
    function handleMemberNameBackspace(event) {
         if (event.key === 'Backspace') {
            const cell = event.target;
            if (cell.textContent.trim() === '' && scheduleBody.children.length > 1) { // 空 & 複数行存在
                event.preventDefault();
                hideSavedPathInfo();
                const currentRow = cell.closest('tr');
                // 削除対象メンバーのデータ削除
                const tds = currentRow.querySelectorAll('td:not(.hidden-column)');
                const memberName = tds.length > 0 ? tds[0].dataset.member : '';
                if (memberName && scheduleData[memberName]) delete scheduleData[memberName];

                const rows = Array.from(scheduleBody.children);
                const currentIndex = rows.indexOf(currentRow);
                let focusMoved = false;
                // 上の行があればフォーカス移動
                if (currentIndex > 0) {
                    const prevRow = rows[currentIndex - 1];
                    const prevMemberCell = prevRow?.querySelector('th[contenteditable="true"]');
                    if (prevMemberCell) {
                        prevMemberCell.focus();
                        // カーソルを末尾に移動
                        const range = document.createRange(); const sel = window.getSelection();
                        range.selectNodeContents(prevMemberCell); range.collapse(false);
                        sel.removeAllRanges(); sel.addRange(range);
                        focusMoved = true;
                    }
                }
                // 上に移動できず、他にまだ行が残る場合は下の行へフォーカス
                if (!focusMoved && rows.length > 1) { // 削除後も行が残ることを確認 (rows.length > 1)
                    const nextRow = rows[currentIndex + 1]; // 削除後の次の行
                    const nextMemberCell = nextRow?.querySelector('th[contenteditable="true"]');
                    if (nextMemberCell) nextMemberCell.focus();
                }
                currentRow.remove(); // 行削除
                setUnsavedChanges(true);
                requestAnimationFrame(adjustRowHeights); // 高さ再調整
                console.info("メンバー行を削除しました");
            }
        }
    }

    /**
     * 日付データセル (td) がクリックされたときの処理。
     * 背景色をトグルし、scheduleDataを更新する。非表示セルは無視する。
     * @param {MouseEvent} event - clickイベントオブジェクト。
     */
    function handleCellClick(event) {
        const target = event.target;
        // TD要素、非表示でない、必要なdata属性を持つ、ことを確認
        if (target.tagName === 'TD' && !target.classList.contains('hidden-column') && target.dataset.date && target.dataset.member !== undefined) {
            hideSavedPathInfo();
            const memberName = target.dataset.member;
            const dateStr = target.dataset.date;
            // メンバー名が空なら警告
            if (memberName === "") {
                 alert("メンバー名を入力してからスケジュールを登録してください。");
                 const row = target.closest('tr');
                 const memberCell = row?.querySelector('th[contenteditable="true"]');
                 if (memberCell) memberCell.focus(); // 名前入力セルにフォーカス
                 return;
            }
            // スケジュールデータ更新（トグル）
            if (!scheduleData[memberName]) scheduleData[memberName] = {};
            if (!scheduleData[memberName][dateStr]) {
                scheduleData[memberName][dateStr] = true;
                target.classList.add('clicked-cell');
            } else {
                delete scheduleData[memberName][dateStr];
                target.classList.remove('clicked-cell');
            }
            setUnsavedChanges(true);
        }
    }

    /**
     * 未保存状態フラグを更新し、UI（未保存メッセージ、保存ボタン）に反映する。
     * @param {boolean} status - 未保存状態にする場合は true。
     */
    function setUnsavedChanges(status) {
        if (hasUnsavedChanges !== status) { // 状態変化時のみログ出力
            console.info(`未保存フラグ変更: ${hasUnsavedChanges} -> ${status}`);
            hasUnsavedChanges = status;
            unsavedChangesElement.style.display = status ? 'inline' : 'none'; // メッセージ表示切替
            saveButton.disabled = !status; // 保存ボタン有効/無効切替
        }
    }

    /**
     * JSONファイルが選択されたときの読み込み処理。
     * ファイル内容をパースし、members, scheduleData, 設定を更新後、現在の年月でカレンダーを再描画する。
     * @param {Event} event - changeイベントオブジェクト (input[type=file])。
     */
    function handleFileLoad(event) {
        hideSavedPathInfo();
        const file = event.target.files[0];
        if (!file) return; // ファイル未選択
        console.info(`JSONファイル読み込み開始: ${file.name}`);
        const reader = new FileReader();
        reader.onload = function(e) {
            const jsonString = e.target.result;
            try {
                const data = JSON.parse(jsonString);
                // データ構造検証
                if (data && typeof data.year === 'number' && typeof data.month === 'number' && Array.isArray(data.members) && typeof data.schedule === 'object' && data.schedule !== null) {
                    // 年月妥当性検証
                    if (data.year > 1900 && data.year < 3000 && data.month >= 1 && data.month <= 12) {
                        // グローバル変数更新
                        members = data.members.filter(m => typeof m === 'string' && m.trim() !== ''); // 空メンバー除外
                        scheduleData = data.schedule || {};
                        const filteredSchedule = {}; // membersに含まれないデータを除外
                        members.forEach(mem => { if(data.schedule[mem]) { filteredSchedule[mem] = data.schedule[mem]; } });
                        scheduleData = filteredSchedule;
                        // 設定読み込み
                        if (data.settings && typeof data.settings.recommendedSavePath === 'string') {
                            currentRecommendedSavePath = data.settings.recommendedSavePath;
                            savePathInput.value = currentRecommendedSavePath;
                        } else { currentRecommendedSavePath = ""; savePathInput.value = ""; }

                        // ★ 表示年月は変更せず、現在の年月で再描画 ★
                        generateSchedule(currentDate.getFullYear(), currentDate.getMonth());
                        errorMessageElement.textContent = ''; // エラーメッセージクリア
                        alert(`${data.year}年${data.month}月のデータを読み込みました。\nカレンダーは現在表示中の ${currentDate.getFullYear()}年${currentDate.getMonth() + 1}月 を維持します。`);
                        setUnsavedChanges(false); // 読み込み直後は未保存状態
                        console.info(`JSONファイル読み込み成功: ${file.name}`);
                    } else { throw new Error("JSON内の年月データが不正です。"); }
                } else { throw new Error("JSONファイルの形式が正しくありません。(year, month, members(配列), schedule(オブジェクト)が必須です)"); }
            } catch (error) {
                console.error(`JSON読み込み/解析失敗 (${file.name}):`, error);
                errorMessageElement.textContent = `エラー: ${error.message}`;
                alert(`ファイルの読み込みに失敗しました。\n${error.message}`);
                initializeSchedule(); // エラー時は初期化
            } finally { fileInput.value = null; } // ファイル選択リセット
        };
        reader.onerror = function(e) {
            console.error('ファイル読み込みエラー:', e);
            errorMessageElement.textContent = 'エラー: ファイルの読み込みに失敗しました。';
            alert('ファイルの読み込み中にエラーが発生しました。');
            fileInput.value = null;
        };
        reader.readAsText(file);
    }

    /**
     * 現在時刻から 'YYYYMMDDHHMMSS' 形式のタイムスタンプ文字列を生成する。
     * @returns {string} タイムスタンプ文字列。
     */
    function getTimestampString() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        return `${year}${month}${day}${hours}${minutes}${seconds}`;
    }

     /**
     * カレンダー絵文字📅をFaviconとして設定する。
     */
    function setCalendarFavicon() {
        const emoji = '📅'; const size = 32;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        if (!ctx) return; // Canvas未対応
        ctx.font = `${size * 0.85}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(emoji, size / 2, size / 2 + size * 0.08); // Y座標微調整
        try {
            const dataURL = canvas.toDataURL('image/png');
            let link = document.querySelector("link[rel*='icon']");
            if (!link) { link = document.createElement('link'); link.rel = 'icon'; document.head.appendChild(link); }
            link.type = 'image/png'; link.href = dataURL;
        } catch (error) { console.error("Faviconの設定に失敗しました:", error); }
    }

    /**
     * アプリケーションの初期化処理（ページ読み込み時に実行）。
     * 祝日データを取得し、現在の年月でカレンダーを描画する。
     */
    async function initializeSchedule() {
        console.info("アプリケーション初期化開始");
        // UI初期状態設定
        monthYearElement.textContent = '祝日データ読込中...';
        scheduleBody.innerHTML = `<tr><td colspan="${MAX_DAYS + 1}" class="loading">データを読み込んでいます...</td></tr>`;
        saveButton.disabled = true;
        settingsContainer.style.display = 'none';
        hideSavedPathInfo();
        setCalendarFavicon();

        await fetchHolidays(); // 祝日データ取得完了を待つ

        // アプリケーション状態リセット
        members = [""]; // 空のメンバー1行
        scheduleData = {};
        currentRecommendedSavePath = "";
        savePathInput.value = "";
        currentDate = new Date(); // 表示年月を現在に

        generateSchedule(currentDate.getFullYear(), currentDate.getMonth()); // 初期カレンダー描画
        setUnsavedChanges(false); // 未保存フラグ解除
        console.info("アプリケーション初期化完了");
        requestAnimationFrame(adjustRowHeights); // 初期高さ調整
    }

    /**
     * 推奨保存先パス表示エリアを非表示にする。
     */
    function hideSavedPathInfo() {
        if (savedPathContainer.style.display !== 'none') {
            savedPathContainer.style.display = 'none';
            savedPathDisplay.textContent = '';
        }
    }

    /**
     * パスコピー機能のフォールバック (document.execCommand)。
     * @param {string} text - コピーするテキスト。
     */
    function copyPathFallback(text) {
        try {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed"; textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus(); textArea.select();
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (!successful) throw new Error('document.execCommand("copy") が失敗しました。');
            alert(`パスをコピーしました (Fallback):\n${text}`);
        } catch (err) {
            alert('クリップボードへのコピーに失敗しました。');
            console.error('パスコピー失敗 (Fallback):', err);
        }
    }

    // --- イベントリスナー設定 ---
    // 各DOM要素にイベント発生時の処理関数を紐付ける

    // テーブルボディのクリック（イベント委任）
    scheduleBody.addEventListener('click', handleCellClick);

    // 操作コントロール
    prevMonthButton.addEventListener('click', () => {
        hideSavedPathInfo();
        if (hasUnsavedChanges && !confirm("未保存の変更があります。移動してもよろしいですか？")) return;
        currentDate.setMonth(currentDate.getMonth() - 1);
        generateSchedule(currentDate.getFullYear(), currentDate.getMonth());
    });
    nextMonthButton.addEventListener('click', () => {
        hideSavedPathInfo();
        if (hasUnsavedChanges && !confirm("未保存の変更があります。移動してもよろしいですか？")) return;
        currentDate.setMonth(currentDate.getMonth() + 1);
        generateSchedule(currentDate.getFullYear(), currentDate.getMonth());
    });
    moveButton.addEventListener('click', () => {
        hideSavedPathInfo();
        const year = parseInt(yearInput.value, 10);
        const month = parseInt(monthInput.value, 10) - 1;
        if (!isNaN(year) && year > 1900 && year < 3000 && !isNaN(month) && month >= 0 && month < 12) {
             if (year === currentDate.getFullYear() && month === currentDate.getMonth()) return; // 移動不要
             if (hasUnsavedChanges && !confirm("未保存の変更があります。移動してもよろしいですか？")) return;
             currentDate = new Date(year, month, 1);
             generateSchedule(currentDate.getFullYear(), currentDate.getMonth());
        } else {
            alert("有効な年月を入力してください (例: 年=2024, 月=1～12)。");
            yearInput.value = currentDate.getFullYear(); monthInput.value = currentDate.getMonth() + 1; // 入力欄を戻す
        }
    });
    todayButton.addEventListener('click', () => {
        hideSavedPathInfo();
        const today = new Date();
        if (currentDate.getFullYear() !== today.getFullYear() || currentDate.getMonth() !== today.getMonth()) {
             if (hasUnsavedChanges && !confirm("未保存の変更があります。移動してもよろしいですか？")) return;
             currentDate = today;
             generateSchedule(currentDate.getFullYear(), currentDate.getMonth());
        } else {
             console.info("既に今月を表示中です。今日の列にスクロールします。");
             const todayHeader = headerRow.querySelector('.today-column');
             if (todayHeader) todayHeader.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    });
    addMemberButton.addEventListener('click', () => addMemberRow(true));

    // ファイル操作
    loadButton.addEventListener('click', () => {
        if (hasUnsavedChanges && !confirm("未保存の変更があります。読み込むと現在の変更は失われますが、よろしいですか？")) return;
        fileInput.click(); // input[type=file]をクリック
    });
    fileInput.addEventListener('change', handleFileLoad); // ファイル選択時のイベント
    saveButton.addEventListener('click', () => {
        hideSavedPathInfo();
        console.info("JSON保存処理開始");
        // 1. 最新のメンバーリストと対応するスケジュールデータを確定
        const currentMembers = [];
        const memberCells = scheduleBody.querySelectorAll('th[contenteditable="true"]');
        const potentialScheduleData = {};
        memberCells.forEach(cell => {
            const name = cell.textContent.trim();
            if (name) { // 空の名前は除外
                currentMembers.push(name);
                const row = cell.closest('tr');
                const tds = row.querySelectorAll('td'); // 全てのtd (非表示含む)
                const originalName = tds.length > 0 ? tds[0].dataset.member : '';
                // 名前変更時のデータ引き継ぎ
                if (originalName && originalName !== name) {
                    if (scheduleData[originalName]) potentialScheduleData[name] = scheduleData[originalName];
                    else potentialScheduleData[name] = scheduleData[name] || {};
                } else if (scheduleData[name]) { potentialScheduleData[name] = scheduleData[name]; }
                else { potentialScheduleData[name] = {}; } // 新規メンバー
                tds.forEach(td => td.dataset.member = name); // dataset更新
            } else { // 名前が空になった場合
                const row = cell.closest('tr');
                const tds = row.querySelectorAll('td');
                const memberNameInDataset = tds.length > 0 ? tds[0].dataset.member : '';
                if(memberNameInDataset && scheduleData[memberNameInDataset]) delete scheduleData[memberNameInDataset]; // 元データ削除
            }
        });
        members = currentMembers; // グローバル変数更新
        scheduleData = potentialScheduleData; // グローバル変数更新

        // 2. 保存用データオブジェクト作成
        const dataToSave = {
            year: currentDate.getFullYear(), month: currentDate.getMonth() + 1,
            members: members, schedule: scheduleData,
            settings: { recommendedSavePath: currentRecommendedSavePath }
        };

        // 3. JSONファイルとしてダウンロード
        try {
            const jsonString = JSON.stringify(dataToSave, null, 2); // 整形
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = getTimestampString();
            a.download = `CL${timestamp}.json`; // ファイル名
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.info(`JSON保存成功: ${a.download}`);
            setUnsavedChanges(false); // 未保存フラグ解除
            if(currentRecommendedSavePath) { // パス表示
                savedPathDisplay.textContent = currentRecommendedSavePath;
                savedPathContainer.style.display = 'flex';
            }
        } catch (error) {
            console.error("JSON保存中にエラー発生:", error);
            errorMessageElement.textContent = "エラー: JSONファイルの保存に失敗しました。";
            alert("JSONファイルの保存中にエラーが発生しました。");
        }
    });

    // 設定関連
    copyPathButton.addEventListener('click', () => {
        const path = currentRecommendedSavePath;
        if (!path) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(path).then(() => { alert(`パスをコピーしました:\n${path}`); })
            .catch(err => { console.error('パスコピー失敗 (Clipboard API):', err); copyPathFallback(path); });
        } else { copyPathFallback(path); }
    });
    openSettingsButton.addEventListener('click', () => {
        hideSavedPathInfo();
        settingsContainer.style.display = 'block';
        savePathInput.value = currentRecommendedSavePath;
        console.info("設定画面を開きました");
    });
    closeSettingsButton.addEventListener('click', () => {
        settingsContainer.style.display = 'none';
        console.info("設定画面を閉じました");
    });
    applySettingsButton.addEventListener('click', () => {
        const newPath = savePathInput.value.trim();
        if (newPath !== currentRecommendedSavePath) {
            currentRecommendedSavePath = newPath;
            setUnsavedChanges(true); // 設定変更も未保存扱い
            console.info("推奨保存先パスを変更（適用）:", newPath);
            alert("推奨保存先パスを変更しました。\nJSON保存時にファイルへ反映されます。");
        }
        settingsContainer.style.display = 'none'; // 適用後閉じる
    });

    // ウィンドウリサイズイベント（debounce処理付き）
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => { requestAnimationFrame(adjustRowHeights); }, RESIZE_DEBOUNCE_TIME);
    });

    // --- 初期化処理を実行 ---
    initializeSchedule();

</script>

</body>
</html>
