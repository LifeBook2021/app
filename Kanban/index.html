<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç´„É≥„Éê„É≥„Éú„Éº„Éâ</title>
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22>
        <text x=%2250%%22 y=%2250%%22 style=%22dominant-baseline:central;text-anchor:middle;font-size:90px;%22>üìã</text></svg>">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <style>
        /* --- Âü∫Êú¨„É¨„Ç§„Ç¢„Ç¶„Éà --- */
        html, body { height: 100%; overflow: hidden; }
        body { background-color: #f8f9fa; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; flex-direction: column; }
        #app { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        .kanban-header { background-color: #0d6efd; color: white; flex-shrink: 0; }
        .container-fluid.board-container { flex-grow: 1; overflow-y: hidden; padding: 1rem; display: flex; flex-direction: column; }
        .kanban-board { display: flex; flex-grow: 1; overflow-x: auto; overflow-y: hidden; padding-bottom: 15px; }

        /* --- „É™„Çπ„ÉàÈñ¢ÈÄ£ --- */
        .kanban-list-wrapper { flex-shrink: 0; width: 320px; margin-right: 1rem; height: 100%; display: flex; flex-direction: column; }
        .kanban-list-wrapper:last-of-type { margin-right: 0; }
        .kanban-list { background-color: #e9ecef; border-radius: 0.25rem; padding: 1rem; display: flex; flex-direction: column; height: 100%; overflow: hidden; }
        .list-header { flex-shrink: 0; }
        .list-content { flex-grow: 1; overflow-y: auto; padding-right: 5px; margin-right: -5px; }
        .list-header-input { background-color: transparent; border: none; font-size: 1.1rem; font-weight: bold; padding: 0.2rem 0; box-shadow: none !important; }
        .list-header-input:focus { background-color: rgba(255, 255, 255, 0.5); }

        /* --- „Ç´„Éº„ÉâÈñ¢ÈÄ£ --- */
        .kanban-card { border: 1px solid #eee; border-radius: 0.25rem; padding: 0.8rem; margin-bottom: 0.8rem; word-wrap: break-word; cursor: pointer; transition: box-shadow 0.2s ease-in-out; }
        .kanban-card:hover { box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .kanban-card:active { cursor: grabbing; }
        .kanban-card:last-child { margin-bottom: 0; }
        .fs-sm { font-size: 0.8rem; }
        .text-muted { color: #6c757d !important; }
        .due-date-badge { padding: 0.2em 0.5em; font-size: 0.75em; font-weight: 600; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0.25rem; flex-shrink: 0; }
        .due-date-none { background-color: #6c757d; color: white; }
        .due-date-overdue { background-color: #dc3545; color: white; }
        .due-date-today { background-color: #ffc107; color: black; }
        .due-date-far { background-color: #0dcaf0; color: black; }
        .card-labels { margin-top: 0.5rem; line-height: 1.5; }
        .card-label-badge { font-size: 0.75em; margin-right: 0.3rem; margin-bottom: 0.3rem; padding: 0.2em 0.5em; color: black; border-radius: 0.25rem; }

        /* --- „Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„ÉóÈñ¢ÈÄ£ --- */
        .drag-handle { cursor: grab; color: #adb5bd; }
        .drag-handle:active { cursor: grabbing; }
        .ghost { opacity: 0.4; background: #c8ebfb; border: 1px dashed #0d6efd; }

        /* --- „Éò„ÉÉ„ÉÄ„Éº„Çø„Ç§„Éà„É´Á∑®ÈõÜ --- */
        .board-title-input { background-color: rgba(0, 0, 0, 0.2); color: white; border: 1px solid rgba(255, 255, 255, 0.5); font-size: 1.25rem; font-weight: 500; line-height: 1.2; padding: 0.25rem 0.5rem; width: auto; display: inline-block; vertical-align: middle; max-width: 300px; margin-right: 1rem; box-shadow: none !important; }
        .board-title-input::placeholder { color: rgba(255, 255, 255, 0.7); }
        .board-title-display { cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.2rem; transition: background-color 0.15s ease-in-out; display: inline-block; margin-right: 1rem; }
        .board-title-display:hover { background-color: rgba(255, 255, 255, 0.1); }
        .kanban-header > div:first-of-type { flex-grow: 1; }
        .kanban-header > div:last-of-type { flex-shrink: 0; }

        /* --- „É¢„Éº„ÉÄ„É´Èñ¢ÈÄ£ --- */
        #modalTaskDescription { min-height: 120px; }
        .form-control-plaintext-like { display: block; width: 100%; padding: 0.375rem 0.75rem; min-height: calc(1.5em + 0.75rem + 2px); line-height: 1.5; color: #212529; background-color: transparent; border: 1px solid #e0e0e0; border-radius: 0.25rem; cursor: pointer; user-select: none; word-wrap: break-word; white-space: pre-wrap; }
        .form-control-plaintext-like.is-placeholder { color: #6c757d; font-style: italic; }
        .form-control-plaintext-like-textarea { min-height: 120px; height: auto; }
        .form-control-plaintext-like:hover { background-color: rgba(0, 0, 0, 0.03); }
        .form-control-plaintext-like-textarea a { color: #0d6efd; text-decoration: underline; }
        .form-control-plaintext-like-textarea a:hover { color: #0a58ca; }

        /* „Ç´„Éº„ÉâËâ≤ÈÅ∏Êäû„Éú„Çø„É≥„ÅÆ„Çπ„Çø„Ç§„É´ */
        .card-color-selector .color-option-label {
            width: 28px; height: 28px; border-radius: 50%; border: 1px solid #ccc; margin-right: 0.5rem; cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; transition: transform 0.1s ease-out, box-shadow 0.15s ease-in-out;
            vertical-align: middle;
        }
        .card-color-selector .btn-check:checked + .color-option-label {
            border-width: 2px; border-color: #0d6efd; transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.25);
        }
        .card-color-selector .btn-check:focus + .color-option-label {
             box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.25);
        }
        .card-color-selector .color-option-label.is-selected:not(.editing-mode) {
            border-width: 2px; border-color: #6c757d;
            transform: scale(1.1);
            box-shadow: none;
        }
        .card-color-selector .color-option-label:not(.editing-mode):hover {
            transform: scale(1.1);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* „É¢„Éº„ÉÄ„É´ÂÜÖ„ÅÆ„É©„Éô„É´Èñ¢ÈÄ£ */
        .labels-section .badge { cursor: default; margin-right: 0.5rem; margin-bottom: 0.5rem; padding: 0.3em 0.6em; color: black; }
        .labels-section .badge .btn-close-label { filter: brightness(0); opacity: 0.7; font-size: 0.8em; cursor: pointer; padding: 0 0.2em; margin-left: 0.3em; }
        .labels-section .badge .btn-close-label:hover { opacity: 1; }
        .label-input-group { display: flex; align-items: center; }
        .label-input-group input { border-top-right-radius: 0; border-bottom-right-radius: 0; }
        .label-input-group button { border-top-left-radius: 0; border-bottom-left-radius: 0; }
        .available-label-list { max-height: 100px; overflow-y: auto; margin-top: 0.5rem; padding: 0.5rem; background-color: #f8f9fa; border-radius: 0.25rem; font-size: 0.9em; }
        .available-label-item { display: inline-block; cursor: pointer; background-color: #e9ecef; border: 1px solid #dee2e6; padding: 0.2em 0.5em; border-radius: 0.2rem; margin-right: 0.4rem; margin-bottom: 0.4rem; }
        .available-label-item:hover { background-color: #ced4da; }

        /* --- „ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„ÉàÈñ¢ÈÄ£ --- */
        .checklist-section .bg-light { background-color: #f0f0f0 !important; }
        .checklist-item { min-height: calc(1.5em + 0.375rem * 2 + 2px); }
        .checklist-item-input { border: none; background-color: transparent; padding-left: 0.25rem; box-shadow: none !important; }
        .checklist-item-input:focus { background-color: rgba(0, 0, 0, 0.05); }
        .checklist-item-input:disabled { background-color: transparent !important; border: none !important; padding-left: 0.25rem; cursor: default !important; }
        .checklist-item-text { padding: 0.25rem 0.5rem; margin-left: 0.25rem; word-break: break-all; line-height: 1.5; cursor: pointer; }
        .checklist-item-text.is-placeholder { color: #6c757d; font-style: italic; }
        .checklist-title-input { border: none; background-color: transparent; padding-left: 0; font-weight: bold; box-shadow: none !important; }
        .checklist-title-input:focus { background-color: rgba(0, 0, 0, 0.05); }
        .checklist-title-input:disabled { border: none !important; background-color: transparent !important; cursor: default !important; }
        .checklist-title-display { padding: 0.25rem 0; word-break: break-all; }
        .form-check-input { cursor: pointer; }

        /* --- „Ç≥„É°„É≥„ÉàÈñ¢ÈÄ£ --- */
        .comment-section .list-group-item { background-color: #f8f9fa; border-color: #dee2e6; padding: 0.5rem 0.75rem; }
        .comment-timestamp { font-size: 0.8em; color: #6c757d; margin-bottom: 0.25rem; }
        .comment-text { white-space: pre-wrap; word-wrap: break-word; }
        .comment-text a { color: #0d6efd; text-decoration: underline; }
        .comment-text a:hover { color: #0a58ca; }
        #newCommentText { min-height: 60px; }
        .comment-edit-area textarea { font-size: 0.9rem; min-height: 60px; }
        .comment-actions button { margin-left: 0.25rem; }

        /* --- Ë°®ÂΩ¢ÂºèË°®Á§∫ --- */
        .table-view-container { flex-grow: 1; overflow-y: auto; padding-top: 0; }
        .table-view-container table { table-layout: fixed; }
        .table-view-container thead.sticky-top {
            position: -webkit-sticky; /* Safari */
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #f8f9fa;
        }
        .table-view-container td, .table-view-container th {
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: middle;
            padding: 0.5rem;
        }
        .table-view-container th { cursor: pointer; user-select: none;}
        .table-view-container th .sort-icon { margin-left: 0.25em; opacity: 0.5; }
        .table-view-container th.active .sort-icon { opacity: 1; }
        .table-view-container td.task-title-cell { white-space: normal; }
        .table-view-container .color-indicator-cell span { display: inline-block; width: 12px; height: 12px; border-radius: 50%; border: 1px solid #ccc; }
        .table-view-container tbody tr:hover { background-color: #f1f1f1; }


        /* --- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ --- */
        input::placeholder{ color: #6c757d; opacity: 0.7; }
        .btn-xs { padding: 0.1rem 0.3rem; font-size: 0.75rem; line-height: 1.2; border-radius: 0.2rem; }

    </style>
</head>

<body>
    <div id="app">
        <!-- „Éò„ÉÉ„ÉÄ„Éº -->
        <div class="kanban-header d-flex justify-content-between align-items-center p-3 shadow-sm">
            <div>
                <div @click="startEditingBoardTitle" v-if="!isEditingBoardTitle" class="board-title-display" title="„Çø„Ç§„Éà„É´Á∑®ÈõÜ">
                    <h1 class="h4 mb-0 d-inline">{{ boardTitle || '„Ç´„É≥„Éê„É≥„Éú„Éº„Éâ' }}</h1>
                </div>
                <input type="text" v-model="boardTitle" v-else class="form-control form-control-sm board-title-input" @blur="finishEditingBoardTitle" @keyup.enter="finishEditingBoardTitle" @keyup.esc="cancelEditingBoardTitle" ref="boardTitleInput" placeholder="„Éú„Éº„Éâ„Çø„Ç§„Éà„É´">
            </div>
            <div class="d-flex align-items-center">
                <!-- JSONË™≠„ÅøËæº„ÅøÊó•ÊôÇ -->
                <span v-if="formattedLastLoadedTime" class="text-white-50 small me-3" title="ÊúÄÁµÇË™≠ËæºÊó•ÊôÇ">
                    <i class="bi bi-clock me-1"></i>{{ formattedLastLoadedTime }}
                </span>

                <!-- „É™„Çπ„ÉàËøΩÂä†„Éú„Çø„É≥ („Ç´„É≥„Éê„É≥Ë°®Á§∫ÊôÇ„ÅÆ„Åø) -->
                <button class="btn btn-outline-light btn-sm me-2" @click="addGroup" title="„É™„Çπ„ÉàËøΩÂä†" v-if="currentView === 'kanban'"><i class="bi bi-plus-lg me-1"></i> „É™„Çπ„ÉàËøΩÂä†</button>

                <!-- „Ç´„Éº„ÉâËøΩÂä†„Éú„Çø„É≥ (Ë°®ÂΩ¢ÂºèË°®Á§∫ÊôÇ„ÅÆ„Åø) -->
                <button class="btn btn-outline-light btn-sm me-2" @click="openNewCardModalForTable" title="„Ç´„Éº„ÉâËøΩÂä†" v-if="currentView === 'table' && tasks.length > 0"><i class="bi bi-plus-lg me-1"></i> „Ç´„Éº„ÉâËøΩÂä†</button>

                <!-- Ë°®Á§∫ÂàáÊõø„Éú„Çø„É≥ -->
                <button class="btn btn-outline-light btn-sm me-2" @click="toggleView" title="Ë°®Á§∫ÂàáÊõø">
                    <i :class="currentView === 'kanban' ? 'bi bi-table' : 'bi bi-kanban-fill'"></i>
                    {{ currentView === 'kanban' ? 'Ë°®ÂΩ¢Âºè' : '„Ç´„É≥„Éê„É≥' }}
                </button>

                <!-- „Åù„ÅÆ‰ªñ„ÅÆ„Éú„Çø„É≥Áæ§ -->
                <label for="fileInput" class="btn btn-outline-light btn-sm me-2" title="JSONË™≠Ëæº"><i class="bi bi-box-arrow-up me-1"></i> JSONË™≠Ëæº</label>
                <input type="file" id="fileInput" accept=".json" @change="loadDataFromFile" style="display: none;">
                <button :class="['btn', 'btn-sm', isDataChanged ? 'btn-warning' : 'btn-outline-light', 'me-2']" @click="saveDataToFile" :title="isDataChanged ? 'Â§âÊõ¥„ÅÇ„ÇäÔºÅJSON‰øùÂ≠ò' : 'JSON‰øùÂ≠ò'">
                    <i class="bi bi-download me-1"></i> JSON‰øùÂ≠ò {{ isDataChanged ? ' *' : '' }}
                </button>
            </div>
        </div>

        <!-- „Éú„Éº„ÉâÊú¨‰Ωì -->
        <div class="container-fluid board-container">
            <!-- „Ç´„É≥„Éê„É≥Ë°®Á§∫ -->
            <div v-if="currentView === 'kanban'" class="kanban-board-wrapper" style="display: flex; flex-direction: column; flex-grow: 1; overflow: hidden;">
                <div class="kanban-board">
                    <draggable :list="tasks" ghost-class="ghost" handle=".list-drag-handle" group="lists" class="d-flex h-100">
                        <div class="kanban-list-wrapper" v-for="(list, listIndex) in tasks" :key="list.id">
                            <div class="kanban-list">
                                <div class="list-header d-flex justify-content-between align-items-center mb-3">
                                    <i class="bi bi-grip-vertical drag-handle list-drag-handle me-2" title="„É™„Çπ„ÉàÁßªÂãï"></i>
                                    <input type="text" class="form-control list-header-input flex-grow-1" v-model="list.name" placeholder="„É™„Çπ„ÉàÂêç">
                                    <button class="btn btn-outline-secondary btn-xs ms-2" @click="delGroup(listIndex)" title="„É™„Çπ„ÉàÂâäÈô§"><i class="bi bi-trash"></i></button>
                                </div>
                                <div class="list-content">
                                    <draggable :list="list.cards" ghost-class="ghost" group="cards" handle=".card-drag-handle" class="h-100">
                                        <div class="kanban-card" v-for="(card, cardIndex) in list.cards" :key="card.id" @click="openTaskModal(card, list.id)" title="Ë©≥Á¥∞Ë°®Á§∫/Á∑®ÈõÜ" :style="{ backgroundColor: getCardBackgroundColor(card.color) }">
                                            <div class="d-flex justify-content-between align-items-start mb-2">
                                                <span class="fw-bold flex-grow-1 me-2 fs-sm">{{ card.title || '(ÁÑ°È°å)' }}</span>
                                                <div class="d-flex align-items-center flex-shrink-0">
                                                    <i class="bi bi-grip-vertical drag-handle card-drag-handle ms-2" @click.stop title="„Ç´„Éº„ÉâÁßªÂãï"></i>
                                                    <button class="btn btn-outline-secondary btn-xs ms-1" @click.stop="confirmDeleteCard(list.cards, cardIndex, card.title)" title="„Ç´„Éº„ÉâÂâäÈô§"><i class="bi bi-x-lg"></i></button>
                                                </div>
                                            </div>
                                            <div class="mb-1" v-if="card.assignee"><span class="fs-sm text-muted"><i class="bi bi-person"></i> {{ card.assignee }}</span></div>
                                            <div class="d-flex align-items-center mb-2" v-if="card.dueDate">
                                                <span class="fs-sm text-muted me-2"><i class="bi bi-calendar-event"></i> ÊúüÈôê:</span>
                                                <span :class="getDueDateBadgeClass(card.dueDate)" class="due-date-badge" :title="getDueDateTooltip(card.dueDate)">{{ formatDueDate(card.dueDate) }}</span>
                                            </div>
                                            <div class="card-labels" v-if="card.labels && card.labels.length > 0">
                                                <span v-for="(label, idx) in card.labels" :key="idx" class="badge card-label-badge" :style="{ backgroundColor: getLabelColor(label) }">{{ label }}</span>
                                            </div>
                                            <div class="fs-sm text-muted mt-2" v-if="card.updatedAt" title="ÊúÄÁµÇÊõ¥Êñ∞Êó•ÊôÇ"><i class="bi bi-pencil-square"></i> {{ formatGeneralTimestamp(card.updatedAt) }}</div>
                                        </div>
                                    </draggable>
                                </div>
                                <div class="mt-3 flex-shrink-0">
                                    <button class="btn btn-outline-secondary btn-sm w-100" @click="openNewCardModal(list)"><i class="bi bi-plus-lg"></i> „Ç´„Éº„ÉâËøΩÂä†</button>
                                </div>
                            </div>
                        </div>
                    </draggable>
                </div>
                <div v-if="tasks.length === 0 && !isLoading" class="alert alert-light text-center border mt-3">„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì...</div>
            </div>

            <!-- Ë°®ÂΩ¢ÂºèË°®Á§∫ -->
            <div v-if="currentView === 'table'" class="table-view-container">
                <table class="table table-hover table-sm">
                    <thead class="table-light sticky-top">
                        <tr>
                            <th scope="col" style="width: 30px;" @click="sortBy('card.color')" :class="{ active: sortKey === 'card.color' }">
                                Ëâ≤
                                <span v-if="sortKey === 'card.color'" class="sort-icon">
                                    <i :class="sortOrders['card.color'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 30%;" @click="sortBy('card.title')" :class="{ active: sortKey === 'card.title' }">
                                „Çø„Çπ„ÇØÂêç
                                <span v-if="sortKey === 'card.title'" class="sort-icon">
                                    <i :class="sortOrders['card.title'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 15%;" @click="sortBy('listName')" :class="{ active: sortKey === 'listName' }">
                                „É™„Çπ„Éà
                                <span v-if="sortKey === 'listName'" class="sort-icon">
                                    <i :class="sortOrders['listName'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 15%;" @click="sortBy('card.assignee')" :class="{ active: sortKey === 'card.assignee' }">
                                ÊãÖÂΩìËÄÖ
                                <span v-if="sortKey === 'card.assignee'" class="sort-icon">
                                    <i :class="sortOrders['card.assignee'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 15%;" @click="sortBy('card.dueDate')" :class="{ active: sortKey === 'card.dueDate' }">
                                ÊúüÈôêÊó•
                                <span v-if="sortKey === 'card.dueDate'" class="sort-icon">
                                    <i :class="sortOrders['card.dueDate'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" @click="sortBy('card.labels')" :class="{ active: sortKey === 'card.labels' }">
                                „É©„Éô„É´
                                <span v-if="sortKey === 'card.labels'" class="sort-icon">
                                    <i :class="sortOrders['card.labels'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 10%;" @click="sortBy('progress')" :class="{ active: sortKey === 'progress' }">
                                ÈÄ≤Êçó
                                <span v-if="sortKey === 'progress'" class="sort-icon">
                                    <i :class="sortOrders['progress'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                            <th scope="col" style="width: 15%;" @click="sortBy('card.updatedAt')" :class="{ active: sortKey === 'card.updatedAt' }">
                                Êõ¥Êñ∞Êó•ÊôÇ
                                <span v-if="sortKey === 'card.updatedAt'" class="sort-icon">
                                    <i :class="sortOrders['card.updatedAt'] === 'asc' ? 'bi bi-arrow-up' : 'bi bi-arrow-down'"></i>
                                </span>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-if="sortedTableData.length === 0 && !isLoading">
                            <td colspan="8" class="text-center text-muted p-3">Ë°®Á§∫„Åô„Çã„Çø„Çπ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</td>
                        </tr>
                        <tr v-for="item in sortedTableData" :key="item.card.id" @click="openTaskModal(item.card, item.listId)" style="cursor: pointer;">
                            <td class="color-indicator-cell text-center">
                                <span :style="{ backgroundColor: getCardBackgroundColor(item.card.color) }" :title="getCardColorName(item.card.color) || '„Éá„Éï„Ç©„É´„ÉàËâ≤'"></span>
                            </td>
                            <td class="task-title-cell"><strong>{{ item.card.title || '(ÁÑ°È°å)' }}</strong></td>
                            <td>{{ item.listName }}</td>
                            <td>{{ item.card.assignee || '-' }}</td>
                            <td>
                                <span v-if="item.card.dueDate" :class="getDueDateBadgeClass(item.card.dueDate) + ' p-1'" :title="getDueDateTooltip(item.card.dueDate)">
                                    {{ formatDueDate(item.card.dueDate) }}
                                </span>
                                <span v-else>-</span>
                            </td>
                            <td>
                                <span v-if="item.card.labels && item.card.labels.length > 0">
                                    <span v-for="(label, idx) in item.card.labels" :key="idx" class="badge me-1" :style="{ backgroundColor: getLabelColor(label) }">{{ label }}</span>
                                </span>
                                <span v-else>-</span>
                            </td>
                            <td class="text-center">{{ getChecklistProgress(item.card).text || '-' }}</td>
                            <td>{{ formatGeneralTimestamp(item.card.updatedAt) }}</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div v-if="isLoading" class="alert alert-info text-center mt-4"><div class="spinner-border spinner-border-sm me-2"></div>Ë™≠Ëæº‰∏≠...</div>
        </div>

        <!-- „Çø„Çπ„ÇØË©≥Á¥∞„É¢„Éº„ÉÄ„É´ -->
        <div class="modal fade" id="taskDetailModal" tabindex="-1" aria-labelledby="taskDetailModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
                <div class="modal-content" :style="{ backgroundColor: editingCard ? getCardBackgroundColor(editingCard.color) : '' }">
                    <div class="modal-header">
                        <h5 class="modal-title">{{ isNewCard ? 'Êñ∞Ë¶è„Çø„Çπ„ÇØ' : '„Çø„Çπ„ÇØË©≥Á¥∞' }}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Èñâ„Åò„Çã"></button>
                    </div>
                    <div class="modal-body" v-if="editingCard">
                        <!-- Âü∫Êú¨ÊÉÖÂ†± -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">„Çø„Ç§„Éà„É´</label>
                            <div v-if="!isEditingMode" class="form-control-plaintext-like" :class="{'is-placeholder': !editingCard.title}" @dblclick="!isEditingMode && switchToEditMode()" title="„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁ∑®ÈõÜ">{{ editingCard.title || 'Êú™Ë®≠ÂÆö' }}</div>
                            <input v-else type="text" class="form-control" v-model="editingCard.title" placeholder="„Çø„Çπ„ÇØ„Çø„Ç§„Éà„É´" id="modalTaskTitle">
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">Ë©≥Á¥∞</label>
                            <div v-if="!isEditingMode" class="form-control-plaintext-like form-control-plaintext-like-textarea" @dblclick="!isEditingMode && switchToEditMode()" title="„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁ∑®ÈõÜ" v-html="linkifiedDescription"></div>
                            <textarea v-else class="form-control" rows="5" v-model="editingCard.description" placeholder="„Çø„Çπ„ÇØË©≥Á¥∞..."></textarea>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label fw-bold">ÊãÖÂΩìËÄÖ</label>
                                    <div v-if="!isEditingMode" class="form-control-plaintext-like" :class="{'is-placeholder': !editingCard.assignee}" @dblclick="!isEditingMode && switchToEditMode()" title="„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁ∑®ÈõÜ">{{ editingCard.assignee || 'Êú™Ë®≠ÂÆö' }}</div>
                                    <input v-else type="text" class="form-control" v-model="editingCard.assignee" placeholder="ÊãÖÂΩìËÄÖÂêç">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label fw-bold">ÊúüÈôêÊó•</label>
                                    <div v-if="!isEditingMode" class="form-control-plaintext-like" :class="{'is-placeholder': !editingCard.dueDate}" @dblclick="!isEditingMode && switchToEditMode()" title="„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁ∑®ÈõÜ">{{ formatDueDate(editingCard.dueDate) }}</div>
                                    <input v-else type="date" class="form-control" v-model="editingCard.dueDate">
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label fw-bold">„Çπ„ÉÜ„Éº„Çø„Çπ</label>
                                    <div v-if="!isEditingMode" class="form-control-plaintext-like" @dblclick="!isEditingMode && switchToEditMode()" title="„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁ∑®ÈõÜ">{{ getListNameById(editingCard.targetListId) }}</div>
                                    <select v-else class="form-select" v-model="editingCard.targetListId">
                                        <option v-for="list in tasks" :key="list.id" :value="list.id">{{ list.name }}</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label class="form-label fw-bold d-block mb-2">„Ç´„Éº„ÉâËâ≤ <small v-if="!isEditingMode && !isNewCard" class="text-muted fw-normal">(„ÇØ„É™„ÉÉ„ÇØ„ÅßÂ§âÊõ¥)</small></label>
                                    <div class="card-color-selector">
                                        <span v-for="colorOption in availableCardColors" :key="colorOption.id">
                                            <input v-if="isEditingMode"
                                                   type="radio"
                                                   class="btn-check"
                                                   name="cardColor"
                                                   :id="'color-' + colorOption.id"
                                                   :value="colorOption.id"
                                                   v-model="editingCard.color"
                                                   autocomplete="off">
                                            <input v-else
                                                   type="radio"
                                                   class="btn-check"
                                                   :name="'cardColorView-' + editingCard.id"
                                                   :id="'color-view-' + colorOption.id + '-' + editingCard.id"
                                                   :checked="editingCard.color === colorOption.id"
                                                   disabled
                                                   autocomplete="off">
                                            <label :for="isEditingMode ? ('color-' + colorOption.id) : ('color-view-' + colorOption.id + '-' + editingCard.id)"
                                                   class="color-option-label"
                                                   :class="{ 'is-selected': editingCard.color === colorOption.id, 'editing-mode': isEditingMode }"
                                                   :style="{ backgroundColor: colorOption.code }"
                                                   :title="colorOption.name + (isEditingMode ? '' : ' „Å´Â§âÊõ¥')"
                                                   @click="!isEditingMode && !isNewCard && changeCardColorImmediately(colorOption.id)">
                                                <i v-if="!isEditingMode && editingCard.color === colorOption.id" class="bi bi-check-lg" style="color: #333; font-size: 0.9em;"></i>
                                            </label>
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div v-if="editingCard && editingCard.updatedAt && !isNewCard" class="text-muted small mt-n2 mb-3">
                            ÊúÄÁµÇÊõ¥Êñ∞: {{ formatGeneralTimestamp(editingCard.updatedAt) }}
                        </div>

                        <hr>

                        <!-- „É©„Éô„É´„Çª„ÇØ„Ç∑„Éß„É≥ -->
                        <div class="mb-3 labels-section">
                            <h6 class="fw-bold mb-2"><i class="bi bi-tags me-1"></i>„É©„Éô„É´</h6>
                            <div class="mb-2" v-if="editingCard.labels && editingCard.labels.length > 0">
                                <span v-for="(label, index) in editingCard.labels" :key="index" class="badge" :style="{ backgroundColor: getLabelColor(label) }">
                                    {{ label }}
                                    <span v-if="isEditingMode" class="btn-close-label" @click="removeLabelFromCard(index)" title="„É©„Éô„É´ÂâäÈô§">&times;</span>
                                </span>
                            </div>
                            <p v-else-if="!isEditingMode" class="text-muted small mb-2">„É©„Éô„É´Êú™Ë®≠ÂÆö</p>

                            <div v-if="isEditingMode">
                                <div class="label-input-group mb-2">
                                    <input type="text" class="form-control form-control-sm" v-model="newLabelInput" @keyup.enter="addLabelToCard" placeholder="Êñ∞Ë¶è„É©„Éô„É´Âêç or Êó¢Â≠ò„É©„Éô„É´ÈÅ∏Êäû" list="availableLabelsList">
                                    <button class="btn btn-outline-secondary btn-sm" @click="addLabelToCard" :disabled="!newLabelInput.trim()" title="„É©„Éô„É´ËøΩÂä†">
                                        <i class="bi bi-plus-circle"></i>
                                    </button>
                                    <datalist id="availableLabelsList">
                                        <option v-for="label in filteredAvailableLabels" :key="label" :value="label"></option>
                                    </datalist>
                                </div>
                                <div v-if="filteredAvailableLabels.length > 0" class="available-label-list border">
                                    <span v-for="label in filteredAvailableLabels" :key="label" class="available-label-item" @click="addExistingLabel(label)">
                                        {{ label }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <hr>

                        <!-- „ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà -->
                        <div class="mb-3 checklist-section" v-if="editingCard && (editingCard.checklists?.length > 0 || isEditingMode)">
                            <h6 class="fw-bold mb-2"><i class="bi bi-check2-square me-1"></i>„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà <small class="text-muted fw-normal" v-if="!isEditingMode">(„ÉÅ„Çß„ÉÉ„ÇØ„ÅØÂç≥ÊôÇÂèçÊò†)</small></h6>
                            <div v-for="(cl, clIdx) in editingCard.checklists" :key="cl.id" class="mb-4 p-3 bg-light border rounded">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <input type="text" class="form-control form-control-sm checklist-title-input flex-grow-1" v-model="cl.title" placeholder="„Çø„Ç§„Éà„É´" :disabled="!isEditingMode" v-if="isEditingMode">
                                    <span class="fw-bold checklist-title-display flex-grow-1" v-else>{{ cl.title || '(ÁÑ°È°å)' }}</span>
                                    <button class="btn btn-outline-danger btn-xs ms-2" @click="confirmDeleteChecklist(clIdx)" v-if="isEditingMode" title="ÂâäÈô§"><i class="bi bi-trash"></i></button>
                                </div>
                                <div v-for="(item, itemIdx) in cl.items" :key="item.id" class="d-flex align-items-center mb-1">
                                    <input class="form-check-input me-2" type="checkbox" v-model="item.completed" @change="toggleChecklistItemCompletion($event, editingCard.currentListId, editingCard.id, cl.id, item.id)" :id="'item-'+item.id">
                                    <input type="text" class="form-control form-control-sm checklist-item-input flex-grow-1" v-model="item.text" placeholder="È†ÖÁõÆ" :disabled="!isEditingMode" v-if="isEditingMode">
                                    <label class="form-check-label flex-grow-1 checklist-item-text" :for="'item-'+item.id" v-else :class="{ 'text-decoration-line-through text-muted': item.completed, 'is-placeholder': !item.text }">{{ item.text || '(Êú™ÂÖ•Âäõ)' }}</label>
                                    <button class="btn btn-outline-secondary btn-xs ms-2" @click="confirmDeleteChecklistItem(cl, itemIdx)" v-if="isEditingMode" title="ÂâäÈô§"><i class="bi bi-x-lg"></i></button>
                                </div>
                                <button class="btn btn-outline-secondary btn-sm mt-2" @click="addChecklistItem(cl)" v-if="isEditingMode"><i class="bi bi-plus-lg"></i> È†ÖÁõÆËøΩÂä†</button>
                            </div>
                            <button class="btn btn-secondary btn-sm w-100 mt-2" @click="addChecklist" v-if="isEditingMode"><i class="bi bi-plus-square-dotted"></i> „ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„ÉàËøΩÂä†</button>
                        </div>

                        <hr v-if="editingCard && (editingCard.checklists?.length > 0 || isEditingMode) && (editingCard.comments?.length > 0 || !isNewCard)">

                        <!-- „Ç≥„É°„É≥„Éà -->
                        <div class="mb-3 comment-section" v-if="editingCard.comments?.length > 0 || !isNewCard || isEditingMode">
                            <h6 class="fw-bold mb-2"><i class="bi bi-chat-left-text me-1"></i>„Ç≥„É°„É≥„Éà <small class="text-muted fw-normal" v-if="!isEditingMode && !isNewCard">(„Ç≥„É°„É≥„Éà/Á∑®ÈõÜ/ÂâäÈô§„ÅØÂç≥ÊôÇÂèçÊò†)</small></h6>
                            <div class="list-group list-group-flush mb-3" v-if="editingCard.comments?.length > 0">
                                <div class="list-group-item" v-for="(comment, index) in editingCard.comments" :key="index">
                                    <div v-if="!comment.isEditing">
                                        <div class="d-flex justify-content-between align-items-start">
                                            <div class="comment-timestamp">{{ formatCommentTimestamp(comment.timestamp) }}</div>
                                            <div class="comment-actions flex-shrink-0" v-if="!isEditingMode && !isNewCard">
                                                <button class="btn btn-outline-secondary btn-xs" @click="startEditingComment(comment, index)" title="„Ç≥„É°„É≥„ÉàÁ∑®ÈõÜ"> <i class="bi bi-pencil-fill"></i> </button>
                                                <button class="btn btn-outline-danger btn-xs" @click="confirmDeleteComment(index)" title="„Ç≥„É°„É≥„ÉàÂâäÈô§"> <i class="bi bi-trash"></i> </button>
                                            </div>
                                        </div>
                                        <div class="comment-text" v-html="linkify(comment.text)"></div>
                                    </div>
                                    <div v-else class="comment-edit-area">
                                        <textarea class="form-control form-control-sm mb-2" v-model="comment.text" rows="3"></textarea>
                                        <div>
                                            <button class="btn btn-success btn-sm me-2" @click="saveCommentEdit(comment, index)">‰øùÂ≠ò</button>
                                            <button class="btn btn-secondary btn-sm" @click="cancelCommentEdit(comment)">„Ç≠„É£„É≥„Çª„É´</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <p v-else-if="!isEditingMode && !isNewCard" class="text-muted small mb-3">„Ç≥„É°„É≥„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
                            <div class="mt-2" v-if="!isNewCard">
                                <textarea class="form-control form-control-sm mb-2" id="newCommentText" rows="2" v-model="newCommentText" placeholder="„Ç≥„É°„É≥„ÉàËøΩÂä†..." @keyup.esc="closeModalOnEsc"></textarea>
                                <button class="btn btn-outline-primary btn-sm" @click="addComment" :disabled="!newCommentText.trim()">
                                    <i class="bi bi-send me-1"></i> „Ç≥„É°„É≥„ÉàËøΩÂä†
                                </button>
                            </div>
                        </div>
                    </div><!-- /.modal-body -->
                    <div class="modal-footer">
                        <template v-if="!isEditingMode && !isNewCard">
                            <button type="button" class="btn btn-info me-auto" @click="duplicateCard" title="„Ç≥„Éî„Éº"><i class="bi bi-files me-1"></i> „Ç≥„Éî„Éº</button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Èñâ„Åò„Çã</button>
                            <button type="button" class="btn btn-primary" @click="switchToEditMode">Á∑®ÈõÜ</button>
                        </template>
                        <template v-if="isEditingMode && !isNewCard">
                            <button type="button" class="btn btn-secondary" @click="cancelEdit">„Ç≠„É£„É≥„Çª„É´</button>
                            <button type="button" class="btn btn-success" @click="saveTaskDetails">‰øùÂ≠ò</button>
                        </template>
                        <template v-if="isNewCard">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Èñâ„Åò„Çã</button>
                            <button type="button" class="btn btn-success" @click="saveTaskDetails">‰øùÂ≠ò</button>
                        </template>
                    </div>
                </div><!-- /.modal-content -->
            </div><!-- /.modal-dialog -->
        </div><!-- /#taskDetailModal -->

    </div> <!-- /#app -->

    <!-- CDN Scripts -->
    <script src="https://unpkg.com/vue@2.6.12"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.24.3/vuedraggable.umd.min.js"></script>

    <script>
        var app = new Vue({
            el: '#app',
            data() {
                return {
                    boardTitle: '„Ç´„É≥„Éê„É≥„Éú„Éº„Éâ', isEditingBoardTitle: false, originalBoardTitle: '',
                    tasks: [], isLoading: false, editingCard: null, taskModalInstance: null,
                    isEditingMode: false, isNewCard: false, isDataChanged: false,
                    _isInternalChange: false,
                    newCommentText: '',
                    availableLabels: [],
                    newLabelInput: '',
                    labelColorCache: {},
                    lastLoadedTime: null,
                    currentView: 'kanban',
                    sortKey: 'card.title',
                    sortOrders: {
                        'card.color': 'asc',
                        'card.title': 'asc',
                        'listName': 'asc',
                        'card.assignee': 'asc',
                        'card.dueDate': 'asc',
                        'card.labels': 'asc',
                        'progress': 'asc',
                        'card.updatedAt': 'desc', // ËøΩÂä†ÔºöÊõ¥Êñ∞Êó•ÊôÇ„Åß„ÅÆ„ÇΩ„Éº„ÉàÈ†Ü
                    },
                    availableCardColors: [
                        { id: 'yellow', name: 'ÈªÑ', code: '#fffacd' },
                        { id: 'blue', name: 'Ê∞¥Ëâ≤', code: '#e7f5ff' },
                        { id: 'green', name: 'Á∑ë', code: '#e6fcf5' },
                        { id: 'pink', name: 'Ê°É', code: '#fff0f6' },
                        { id: 'purple', name: 'Á¥´', code: '#f3e8ff' },
                        { id: 'gray', name: 'ÁÅ∞', code: '#f8f9fa' }
                    ]
                }
            },
            computed: {
                getListNameById() { return (id) => { if(!id) return 'Ôºà„É™„Çπ„ÉàÊú™ÊåáÂÆöÔºâ'; const l=this.tasks.find(l=>l.id===id); return l?l.name:'Ôºà‰∏çÊòé„É™„Çπ„ÉàÔºâ'; }; },
                linkifiedDescription() { if(this.editingCard?.description) return this.linkify(this.editingCard.description); return '<span class="is-placeholder" style="white-space:pre-wrap">Êú™Ë®≠ÂÆö</span>'; },
                filteredAvailableLabels() {
                    const input = this.newLabelInput.toLowerCase().trim();
                    const currentLabels = this.editingCard?.labels?.map(l => l.toLowerCase()) || [];
                    return this.availableLabels.filter(label =>
                        !currentLabels.includes(label.toLowerCase()) &&
                        (input === '' || label.toLowerCase().includes(input))
                    ).sort();
                },
                formattedLastLoadedTime() {
                    if (!this.lastLoadedTime) return null;
                    const d = this.lastLoadedTime;
                    const pad = (n) => String(n).padStart(2, '0');
                    return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                },
                sortedTableData() {
                    if (this.currentView !== 'table') return [];
                    let flatTasks = [];
                    this.tasks.forEach(list => {
                        list.cards.forEach(card => {
                            flatTasks.push({
                                listId: list.id,
                                listName: list.name,
                                card: card,
                                progressData: this.getChecklistProgress(card)
                            });
                        });
                    });

                    if (this.sortKey) {
                        const order = this.sortOrders[this.sortKey] === 'asc' ? 1 : -1;
                        flatTasks.sort((a, b) => {
                            let valA, valB;

                            if (this.sortKey === 'progress') {
                                valA = a.progressData.percentage;
                                valB = b.progressData.percentage;
                            } else if (this.sortKey === 'card.labels') {
                                valA = (a.card.labels && a.card.labels.length > 0) ? a.card.labels[0].toLowerCase() : '';
                                valB = (b.card.labels && b.card.labels.length > 0) ? b.card.labels[0].toLowerCase() : '';
                            } else if (this.sortKey === 'card.color') {
                                valA = this.getCardColorName(a.card.color)?.toLowerCase() || '';
                                valB = this.getCardColorName(b.card.color)?.toLowerCase() || '';
                            } else {
                                valA = this.getValueByPath(a, this.sortKey);
                                valB = this.getValueByPath(b, this.sortKey);
                            }

                            valA = (valA === null || typeof valA === 'undefined') ? '' : valA;
                            valB = (valB === null || typeof valB === 'undefined') ? '' : valB;


                            if (this.sortKey === 'card.dueDate') {
                                if (!valA && valB) return order === 1 ? 1 : -1;
                                if (valA && !valB) return order === 1 ? -1 : 1;
                                if (!valA && !valB) return 0;
                                valA = new Date(valA).getTime();
                                valB = new Date(valB).getTime();
                            } else if (this.sortKey === 'card.updatedAt') { // updatedAt „ÅÆ„ÇΩ„Éº„Éà
                                const timeA = valA ? new Date(valA).getTime() : (order === 1 ? Infinity : -Infinity);
                                const timeB = valB ? new Date(valB).getTime() : (order === 1 ? Infinity : -Infinity);
                                if (timeA < timeB) return -1 * order;
                                if (timeA > timeB) return 1 * order;
                                return 0;
                            } else if (typeof valA === 'string') {
                                valA = valA.toLowerCase();
                                valB = valB.toLowerCase();
                            }

                            if (valA < valB) return -1 * order;
                            if (valA > valB) return 1 * order;
                            return 0;
                        });
                    }
                    return flatTasks;
                }
            },
            mounted() {
                const el = document.getElementById('taskDetailModal');
                if (el) {
                    this.taskModalInstance = new bootstrap.Modal(el);
                    el.addEventListener('hidden.bs.modal', () => {
                        this.editingCard=null;
                        this.isEditingMode=false;
                        this.isNewCard=false;
                        this.newCommentText='';
                        this.newLabelInput='';
                    });
                }
                this.updateAvailableLabels();
            },
            methods: {
                toggleView() {
                    this.currentView = this.currentView === 'kanban' ? 'table' : 'kanban';
                },
                sortBy(key) {
                    if (this.sortKey === key) {
                        this.sortOrders[key] = this.sortOrders[key] === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortKey = key;
                        if (!this.sortOrders[key]) {
                             this.$set(this.sortOrders, key, 'asc');
                        }
                    }
                },
                getValueByPath(obj, path) {
                    if (!path) return obj;
                    const properties = path.split('.');
                    return properties.reduce((prev, curr) => (prev && prev[curr]) ? prev[curr] : null, obj);
                },
                generateId() { return '_' + Math.random().toString(36).substr(2, 9); },
                markDataChanged() { if (!this._isInternalChange) this.isDataChanged = true; },
                saveDataToFile() {
                    const data = { title: this.boardTitle, tasks: this.tasks };
                    if (data.tasks.length === 0 && !(data.title||'').trim()) {
                        alert("‰øùÂ≠ò„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
                        return;
                    }
                    try {
                        const now = new Date();
                        const pad = (n) => String(n).padStart(2, '0');
                        const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
                        const filename = `KBD${timestamp}.json`;
                        const dataString = JSON.stringify(data, null, 2);
                        const blob = new Blob([dataString], {type:"application/json"});
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.style.display="none"; a.href=url; a.download=filename;
                        document.body.appendChild(a); a.click();
                        URL.revokeObjectURL(url); document.body.removeChild(a);
                        this._isInternalChange=true; this.isDataChanged=false;
                        this.$nextTick(()=>this._isInternalChange=false);
                    } catch(e) {
                        console.error("JSON„Éá„Éº„Çø„ÅÆ‰øùÂ≠ò‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:", e);
                        alert("„Éá„Éº„Çø„ÅÆ‰øùÂ≠ò‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ");
                    }
                },
                loadDataFromFile(event) {
                    const file = event.target.files[0];
                    const inputElement = event.target;
                    if (!file || !file.type.match('json')) {
                        alert("JSON„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                        inputElement.value=''; return;
                    }
                    this.isLoading = true;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this._isInternalChange = true;
                        try {
                            const loadedData = JSON.parse(e.target.result);
                            let tasks = [], boardTitle = '„Ç´„É≥„Éê„É≥„Éú„Éº„Éâ';
                            if(typeof loadedData === 'object' && loadedData !== null && Array.isArray(loadedData.tasks)) {
                                boardTitle = loadedData.title || boardTitle;
                                tasks = this.validateTasksData(loadedData.tasks);
                            } else if(Array.isArray(loadedData)) {
                                console.warn("Âè§„ÅÑÂΩ¢Âºè„ÅÆJSON„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ");
                                tasks = this.validateTasksData(loadedData);
                            } else {
                                throw new Error("ÁÑ°Âäπ„Å™JSON„Éá„Éº„ÇøÂΩ¢Âºè„Åß„Åô„ÄÇ");
                            }
                            this.boardTitle = boardTitle;
                            this.$set(this,'tasks', tasks);
                            this.isDataChanged = false;
                            this.updateAvailableLabels();
                            this.lastLoadedTime = new Date();
                            alert("„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ");
                        } catch(err) {
                            console.error("JSON„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Åæ„Åü„ÅØËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:", err);
                            alert("„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + err.message);
                        } finally {
                            inputElement.value = ''; this.isLoading = false;
                            this.$nextTick(() => this._isInternalChange = false);
                        }
                    };
                    reader.onerror = (e) => {
                        console.error("„Éï„Ç°„Ç§„É´Ë™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", e);
                        alert("„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøÂèñ„Çä„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
                        inputElement.value = ''; this.isLoading = false; this._isInternalChange = false;
                    };
                    reader.readAsText(file);
                },
                validateTasksData(tasks) {
                    const validColorIds = this.availableCardColors.map(c => c.id);
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';
                    return Array.isArray(tasks) ? tasks.map(list => {
                        if(!list || typeof list !=='object') return null;
                        const listId = list.id || this.generateId();
                        const cards = (Array.isArray(list.cards)?list.cards:[]).map(card => {
                            if(!card || typeof card !=='object') return null;
                            let dueDate = (typeof card.dueDate === 'string' && card.dueDate.match(/^\d{4}-\d{2}-\d{2}$/)) ? card.dueDate : null;
                            if(dueDate === "") dueDate = null;
                            const checklists = this.validateChecklists(card.checklists);
                            const comments = this.validateComments(card.comments);
                            const labels = Array.isArray(card.labels) ? card.labels.filter(lbl => typeof lbl === 'string' && lbl.trim()).map(lbl => lbl.trim()) : [];
                            let cardColor = card.color;
                            if (!cardColor || !validColorIds.includes(cardColor)) {
                                cardColor = defaultColorId;
                            }
                            return {
                                id: card.id || this.generateId(),
                                title: String(card.title || ''),
                                assignee: String(card.assignee || ''),
                                dueDate: dueDate,
                                description: String(card.description || ''),
                                checklists: checklists,
                                comments: comments,
                                labels: labels,
                                color: cardColor,
                                updatedAt: card.updatedAt || new Date().toISOString() // updatedAt „ÅÆÂàùÊúüÂåñ
                            };
                        }).filter(card => card !== null);
                        return { id: listId, name: String(list.name || 'ÁÑ°È°å'), cards: cards };
                    }).filter(list => list !== null) : [];
                },
                validateChecklists(checklists) {
                    return Array.isArray(checklists) ? checklists.map(cl => {
                        if(!cl || typeof cl !=='object') return null;
                        const clId = cl.id || this.generateId();
                        const items = (Array.isArray(cl.items)?cl.items:[]).map(item => {
                            if(!item || typeof item !=='object') return null;
                            return { id: item.id || this.generateId(), text: String(item.text || ''), completed: Boolean(item.completed || false) };
                        }).filter(item => item !== null);
                        return { id: clId, title: String(cl.title || ''), items: items };
                    }).filter(cl => cl !== null) : [];
                },
                validateComments(comments) {
                    return Array.isArray(comments) ? comments.map(c => {
                        if(!c || typeof c !=='object' || !c.text || !c.timestamp || isNaN(Date.parse(c.timestamp))) return null;
                        return { text: String(c.text), timestamp: String(c.timestamp) };
                    }).filter(c => c !== null) : [];
                },
                addGroup() {
                    this.tasks.push({ id:this.generateId(), name:'Êñ∞„Åó„ÅÑ„É™„Çπ„Éà', cards:[] });
                },
                delGroup(listIndex) {
                    const listName = (this.tasks[listIndex]?.name) || '(ÁÑ°È°å„ÅÆ„É™„Çπ„Éà)';
                    if(confirm(`„É™„Çπ„Éà„Äå${listName}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆ„É™„Çπ„ÉàÂÜÖ„ÅÆ„Ç´„Éº„Éâ„ÇÇ„Åô„Åπ„Å¶ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`)) {
                        this.tasks.splice(listIndex, 1);
                    }
                },
                confirmDeleteCard(cardList, cardIndex, cardTitle) {
                    const title = cardTitle || '(ÁÑ°È°å„ÅÆ„Ç´„Éº„Éâ)';
                    if(confirm(`„Ç´„Éº„Éâ„Äå${title}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
                        this.delTask(cardList, cardIndex);
                    }
                },
                delTask(cardList, cardIndex) {
                    if(Array.isArray(cardList) && cardIndex >= 0 && cardIndex < cardList.length) {
                        cardList.splice(cardIndex, 1);
                    } else {
                        console.error("„Ç´„Éº„ÉâÂâäÈô§„Ç®„É©„Éº: ‰∏çÊ≠£„Å™„É™„Çπ„Éà„Åæ„Åü„ÅØ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åß„Åô„ÄÇ", cardList, cardIndex);
                    }
                },
                duplicateCard() {
                    if (!this.editingCard?.id || this.isNewCard) return;
                    const originalListId = this.editingCard.currentListId;
                    const originalList = this.tasks.find(l => l.id === originalListId);
                    if (!originalList) { alert("„Ç´„Éº„Éâ„ÅÆ„Ç≥„Éî„Éº‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"); return; }
                    const duplicatedChecklists = JSON.parse(JSON.stringify(this.editingCard.checklists || [])).map(cl => {
                        cl.id = this.generateId();
                        cl.items.forEach(item => item.id = this.generateId());
                        return cl;
                    });
                    const duplicatedComments = JSON.parse(JSON.stringify(this.editingCard.comments || []));
                    const duplicatedLabels = JSON.parse(JSON.stringify(this.editingCard.labels || []));
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';

                    const newCard = {
                        id: this.generateId(),
                        title: `${this.editingCard.title || '(ÁÑ°È°å)'} („Ç≥„Éî„Éº)`,
                        assignee: this.editingCard.assignee || '',
                        dueDate: this.editingCard.dueDate,
                        description: this.editingCard.description || '',
                        checklists: duplicatedChecklists,
                        comments: duplicatedComments,
                        labels: duplicatedLabels,
                        color: this.editingCard.color || defaultColorId,
                        updatedAt: new Date().toISOString() // updatedAt „ÇíË®≠ÂÆö
                    };
                    originalList.cards.push(newCard);
                    this.updateAvailableLabels();
                    if (this.taskModalInstance) this.taskModalInstance.hide();
                    this.$nextTick(() => alert(`„Ç´„Éº„Éâ„Äå${newCard.title}„Äç„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ`));
                },
                linkify(text) {
                    if (!text) return '';
                    let escapedText = text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
                    const urlPattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
                    let linkifiedText = escapedText.replace(urlPattern, url => {
                        let fullUrl = url;
                        if(url.toLowerCase().startsWith('www.')) {
                            fullUrl = 'http://' + url;
                        }
                        return `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                    });
                    return linkifiedText.replace(/\n/g, '<br>');
                },
                formatDueDate(dateString) {
                    if(!dateString) return 'Êú™Ë®≠ÂÆö';
                    try {
                        const [year, month, day] = dateString.split('-').map(Number);
                        const date = new Date(year, month - 1, day);
                        if(isNaN(date.getTime())) return 'ÁÑ°Âäπ„Å™Êó•‰ªò';
                        const weekdays = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
                        const weekday = weekdays[date.getDay()];
                        return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}(${weekday})`;
                    } catch(e) {
                        return 'Êó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Ç®„É©„Éº';
                    }
                },
                getDueDateBadgeClass(dateString) {
                    if(!dateString) return 'due-date-none';
                    try {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const [year, month, day] = dateString.split('-').map(Number);
                        const dueDate = new Date(year, month - 1, day);
                        dueDate.setHours(0, 0, 0, 0);
                        if(isNaN(dueDate.getTime())) return 'due-date-none';
                        const diffDays = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                        if(diffDays < 0) return 'due-date-overdue';
                        else if(diffDays <= 7) return 'due-date-today';
                        else return 'due-date-far';
                    } catch(e) {
                        return 'due-date-none';
                    }
                },
                getDueDateTooltip(dateString) {
                    if(!dateString) return 'ÊúüÈôêÊú™Ë®≠ÂÆö';
                    try {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const [year, month, day] = dateString.split('-').map(Number);
                        const dueDate = new Date(year, month - 1, day);
                        dueDate.setHours(0, 0, 0, 0);
                        if(isNaN(dueDate.getTime())) return 'ÁÑ°Âäπ„Å™Êó•‰ªò';
                        const diffDays = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                        if(diffDays < 0) return `${Math.abs(diffDays)}Êó•Ââç„ÅåÊúüÈôê„Åß„Åó„Åü`;
                        if(diffDays === 0) return '‰ªäÊó•„ÅåÊúüÈôê„Åß„Åô';
                        return `„ÅÇ„Å®${diffDays}Êó•`;
                    } catch(e) {
                        return 'Êó•Êï∞Ë®àÁÆó„Ç®„É©„Éº';
                    }
                },
                formatGeneralTimestamp(timestampString) { // ËøΩÂä†ÔºöÊ±éÁî®Êó•ÊôÇ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
                    if (!timestampString) return '-';
                    try {
                        const date = new Date(timestampString);
                        if (isNaN(date.getTime())) return 'ÁÑ°Âäπ„Å™Êó•ÊôÇ';
                        const pad = (n) => String(n).padStart(2, '0');
                        return `${date.getFullYear()}/${pad(date.getMonth() + 1)}/${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
                    } catch (e) {
                        return 'Êó•ÊôÇ„Ç®„É©„Éº';
                    }
                },
                openTaskModal(card, listId) {
                    if (!card?.id || !listId) {
                        console.error("„Çø„Çπ„ÇØ„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åë„Åæ„Åõ„Çì: ‰∏çÊ≠£„Å™„Ç´„Éº„Éâ„Åæ„Åü„ÅØ„É™„Çπ„ÉàID„Åß„Åô„ÄÇ", card, listId);
                        return;
                    }
                    this.isNewCard = false;
                    this.isEditingMode = false;
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';
                    this.editingCard = JSON.parse(JSON.stringify({
                        ...card,
                        dueDate: card.dueDate === "" ? null : card.dueDate,
                        description: card.description || '',
                        checklists: Array.isArray(card.checklists) ? card.checklists : [],
                        comments: Array.isArray(card.comments) ? card.comments : [],
                        labels: Array.isArray(card.labels) ? card.labels : [],
                        color: card.color || defaultColorId,
                        updatedAt: card.updatedAt || new Date().toISOString(), // Êó¢Â≠ò„Éá„Éº„Çø„Å´„Å™„Åë„Çå„Å∞ÁèæÂú®Êó•ÊôÇ
                        currentListId: listId,
                        targetListId: listId
                    }));
                    this.newLabelInput = '';
                    if (this.taskModalInstance) this.taskModalInstance.show();
                },
                openNewCardModal(list) {
                    if (!list?.id) {
                        console.error("Êñ∞Ë¶è„Ç´„Éº„Éâ„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åë„Åæ„Åõ„Çì: ‰∏çÊ≠£„Å™„É™„Çπ„Éà„Åß„Åô„ÄÇ", list);
                        return;
                    }
                    this.isNewCard = true;
                    this.isEditingMode = true;
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';
                    this.editingCard = {
                        id: null, title: '', assignee: '', dueDate: null, description: '',
                        checklists: [], comments: [], labels: [],
                        color: defaultColorId,
                        updatedAt: new Date().toISOString(), // Êñ∞Ë¶è‰ΩúÊàêÊôÇ„Å´updatedAt„ÇíË®≠ÂÆö
                        currentListId: list.id,
                        targetListId: list.id
                    };
                    this.newLabelInput = '';
                    if (this.taskModalInstance) {
                        this.taskModalInstance.show();
                        this.$nextTick(() => { document.getElementById('modalTaskTitle')?.focus(); });
                    }
                },
                openNewCardModalForTable() {
                    if (this.tasks.length === 0) {
                        alert("„Ç´„Éº„Éâ„ÇíËøΩÂä†„Åô„Çã„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åæ„Åö„Ç´„É≥„Éê„É≥Ë°®Á§∫„Åß„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                        return;
                    }
                    this.isNewCard = true;
                    this.isEditingMode = true;
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';
                    const defaultListId = this.tasks[0].id;
                    this.editingCard = {
                        id: null, title: '', assignee: '', dueDate: null, description: '',
                        checklists: [], comments: [], labels: [],
                        color: defaultColorId,
                        updatedAt: new Date().toISOString(), // Êñ∞Ë¶è‰ΩúÊàêÊôÇ„Å´updatedAt„ÇíË®≠ÂÆö
                        currentListId: defaultListId,
                        targetListId: defaultListId
                    };
                    this.newLabelInput = '';
                    if (this.taskModalInstance) {
                        this.taskModalInstance.show();
                        this.$nextTick(() => { document.getElementById('modalTaskTitle')?.focus(); });
                    }
                },
                switchToEditMode() {
                    if(!this.isEditingMode){
                        this.isEditingMode = true;
                        this.$nextTick(() => {
                            const titleInput = document.getElementById('modalTaskTitle');
                            if(titleInput && !titleInput.disabled){
                                titleInput.focus();
                                if(titleInput.select) titleInput.select();
                            }
                        });
                    }
                },
                cancelEdit() {
                    if(this.isNewCard){
                        if(this.taskModalInstance) this.taskModalInstance.hide();
                    } else if(this.editingCard){
                        const originalList = this.tasks.find(l => l.id === this.editingCard.currentListId);
                        const originalCard = originalList?.cards.find(c => c.id === this.editingCard.id);
                        if(originalCard){
                            const modalBody = document.querySelector('#taskDetailModal .modal-body');
                            const currentScrollTop = modalBody ? modalBody.scrollTop : 0;
                            this.openTaskModal(originalCard, this.editingCard.currentListId); // ÂÜçÂ∫¶Èñã„Åè„Åì„Å®„ÅßÂÖÉ„Å´Êàª„Åô
                            this.$nextTick(() => { if(modalBody) modalBody.scrollTop = currentScrollTop; });
                        } else {
                            this.isEditingMode = false; // ‰∏á„Åå‰∏Ä„Ç´„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
                        }
                    }
                },
                saveTaskDetails() {
                    if (!this.editingCard?.targetListId) {
                        alert("„Ç´„Éº„Éâ„ÅÆ‰øùÂ≠òÂÖà„É™„Çπ„Éà„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ");
                        return;
                    }
                    if (this.editingCard.dueDate === "") {
                        this.editingCard.dueDate = null;
                    }
                    const defaultColorId = this.availableCardColors.find(c => c.id === 'gray')?.id || this.availableCardColors[0]?.id || 'yellow';
                    const cardDataToSave = {
                        id: this.editingCard.id,
                        title: this.editingCard.title || '',
                        assignee: this.editingCard.assignee || '',
                        dueDate: this.editingCard.dueDate,
                        description: this.editingCard.description || '',
                        checklists: this.editingCard.checklists || [],
                        comments: this.editingCard.comments?.map(c => ({ text: c.text, timestamp: c.timestamp })) || [],
                        labels: this.editingCard.labels || [],
                        color: this.editingCard.color || defaultColorId,
                        updatedAt: new Date().toISOString() // ‰øùÂ≠òÊôÇ„Å´updatedAt„ÇíÊõ¥Êñ∞
                    };
                    const targetListId = this.editingCard.targetListId;
                    if (this.isNewCard) {
                        cardDataToSave.id = this.generateId();
                        const targetList = this.tasks.find(l => l.id === targetListId);
                        if (!targetList) { alert("‰øùÂ≠òÂÖà„ÅÆ„É™„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"); return; }
                        targetList.cards.push(cardDataToSave);
                    } else {
                        const currentListId = this.editingCard.currentListId;
                        const cardId = this.editingCard.id;
                        if (!currentListId || !cardId) { alert("„Ç´„Éº„ÉâÊÉÖÂ†±„ÅÆÊõ¥Êñ∞‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ(ID‰∏ç‰∏ÄËá¥)"); return; }
                        const originalList = this.tasks.find(l => l.id === currentListId);
                        if (!originalList) { alert("ÂÖÉ„ÅÆ„É™„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"); return; }
                        const originalCardIndex = originalList.cards.findIndex(c => c.id === cardId);
                        if (originalCardIndex === -1) { alert("Êõ¥Êñ∞ÂØæË±°„ÅÆ„Ç´„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"); return; }
                        if (currentListId === targetListId) {
                            this.$set(originalList.cards, originalCardIndex, cardDataToSave);
                        } else {
                            const targetList = this.tasks.find(l => l.id === targetListId);
                            if (!targetList) { alert("ÁßªÂãïÂÖà„ÅÆ„É™„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ"); return; }
                            originalList.cards.splice(originalCardIndex, 1);
                            targetList.cards.push(cardDataToSave);
                        }
                    }
                    this.updateAvailableLabels();
                    if (this.taskModalInstance) this.taskModalInstance.hide();
                },
                closeModalOnEsc(event) { },
                startEditingBoardTitle() {
                    if(!this.isEditingBoardTitle){
                        this.originalBoardTitle = this.boardTitle;
                        this.isEditingBoardTitle = true;
                        this.$nextTick(()=>{ if(this.$refs.boardTitleInput){ this.$refs.boardTitleInput.focus(); this.$refs.boardTitleInput.select(); } });
                    }
                },
                finishEditingBoardTitle() {
                    if(this.isEditingBoardTitle){
                        const trimmedTitle = this.boardTitle.trim();
                        if(!trimmedTitle) { this.boardTitle = this.originalBoardTitle || '„Ç´„É≥„Éê„É≥„Éú„Éº„Éâ'; }
                        else if (this.boardTitle !== trimmedTitle) { this.boardTitle = trimmedTitle; }
                        this.isEditingBoardTitle = false;
                    }
                },
                cancelEditingBoardTitle() {
                    if(this.isEditingBoardTitle){
                        if(this.boardTitle !== this.originalBoardTitle) { this.boardTitle = this.originalBoardTitle; }
                        this.isEditingBoardTitle = false;
                    }
                },
                addChecklist() {
                    if(!this.editingCard) return;
                    if(!Array.isArray(this.editingCard.checklists)) { this.$set(this.editingCard, 'checklists', []); }
                    this.editingCard.checklists.push({id: this.generateId(), title: '', items: []});
                },
                confirmDeleteChecklist(checklistIndex) {
                    const checklistTitle = this.editingCard?.checklists[checklistIndex]?.title || '(ÁÑ°È°å„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà)';
                    if(confirm(`„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà„Äå${checklistTitle}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) { this.deleteChecklist(checklistIndex); }
                },
                deleteChecklist(checklistIndex) { if(this.editingCard?.checklists) { this.editingCard.checklists.splice(checklistIndex, 1); } },
                addChecklistItem(checklist) { if(checklist && Array.isArray(checklist.items)) { checklist.items.push({id: this.generateId(), text: '', completed: false}); } },
                confirmDeleteChecklistItem(checklist, itemIndex) {
                     const itemText = checklist?.items[itemIndex]?.text || '(Êú™ÂÖ•Âäõ„ÅÆÈ†ÖÁõÆ)';
                     if(confirm(`„ÉÅ„Çß„ÉÉ„ÇØÈ†ÖÁõÆ„Äå${itemText}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) { this.deleteChecklistItem(checklist, itemIndex); }
                },
                deleteChecklistItem(checklist, itemIndex) { if(checklist?.items) { checklist.items.splice(itemIndex, 1); } },
                toggleChecklistItemCompletion(event, listId, cardId, checklistId, itemId) {
                    const isCompleted = event.target.checked;
                    const listIndex = this.tasks.findIndex(l => l.id === listId); if(listIndex === -1) return;
                    const cardIndex = this.tasks[listIndex].cards.findIndex(c => c.id === cardId); if(cardIndex === -1) return;

                    const cardToUpdate = this.tasks[listIndex].cards[cardIndex];
                    if(!cardToUpdate.checklists) return;
                    const checklistIndex = cardToUpdate.checklists.findIndex(cl => cl.id === checklistId); if(checklistIndex === -1) return;
                    const itemIndex = cardToUpdate.checklists[checklistIndex].items.findIndex(i => i.id === itemId); if(itemIndex === -1) return;

                    this.$set(cardToUpdate.checklists[checklistIndex].items[itemIndex], 'completed', isCompleted);
                    this.$set(cardToUpdate, 'updatedAt', new Date().toISOString()); // ÂÆü„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞

                    if(this.editingCard && this.editingCard.id === cardId){
                        const editingCl = this.editingCard.checklists?.find(cl => cl.id === checklistId);
                        const editingItem = editingCl?.items.find(i => i.id === itemId);
                        if(editingItem) this.$set(editingItem, 'completed', isCompleted);
                        this.$set(this.editingCard, 'updatedAt', new Date().toISOString()); // „É¢„Éº„ÉÄ„É´ÂÜÖ„Éá„Éº„Çø„ÅÆ updatedAt „ÇÇÊõ¥Êñ∞
                    }
                    this.markDataChanged();
                },
                getChecklistProgress(card) {
                    if (!card.checklists || card.checklists.length === 0) return { text: '', percentage: 0 };
                    let totalItems = 0;
                    let completedItems = 0;
                    card.checklists.forEach(cl => {
                        cl.items.forEach(item => {
                            totalItems++;
                            if (item.completed) completedItems++;
                        });
                    });
                    const percentage = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
                    const text = totalItems > 0 ? `${completedItems}/${totalItems}` : '';
                    return { text, percentage };
                },
                addComment() {
                    if (!this.editingCard || !this.newCommentText.trim()) return;
                    const text = this.newCommentText.trim();
                    const timestamp = new Date().toISOString();
                    const newComment = { text: text, timestamp: timestamp, isEditing: false };

                    if (!Array.isArray(this.editingCard.comments)) { this.$set(this.editingCard, 'comments', []); }
                    this.editingCard.comments.push(newComment);
                    this.$set(this.editingCard, 'updatedAt', new Date().toISOString()); // „É¢„Éº„ÉÄ„É´ÂÜÖ„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞

                    if (!this.isEditingMode && !this.isNewCard) {
                        const { currentListId, id: cardId } = this.editingCard;
                        if (!currentListId || !cardId) return;
                        const listIndex = this.tasks.findIndex(l => l.id === currentListId); if (listIndex === -1) return;
                        const cardIndex = this.tasks[listIndex].cards.findIndex(c => c.id === cardId); if (cardIndex === -1) return;
                        const card = this.tasks[listIndex].cards[cardIndex];
                        if (!Array.isArray(card.comments)) { this.$set(card, 'comments', []); }
                        card.comments.push({ text: newComment.text, timestamp: newComment.timestamp });
                        this.$set(card, 'updatedAt', new Date().toISOString()); // ÂÆü„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞
                        this.markDataChanged();
                    }
                    this.newCommentText = '';
                },
                formatCommentTimestamp(timestampString) {
                    if (!timestampString) return '';
                    try {
                        const date = new Date(timestampString);
                        if (isNaN(date.getTime())) return 'ÁÑ°Âäπ„Å™Êó•ÊôÇ';
                        const pad = (n) => String(n).padStart(2, '0');
                        return `${date.getFullYear()}/${pad(date.getMonth() + 1)}/${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
                    } catch(e) { return 'Êó•ÊôÇ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Ç®„É©„Éº'; }
                },
                 startEditingComment(comment, index) {
                    this.editingCard.comments.forEach((c, i) => { if(c.isEditing && i !== index) { this.cancelCommentEdit(c); } });
                    this.$set(comment, 'isEditing', true);
                    this.$set(comment, 'originalText', comment.text);
                },
                saveCommentEdit(comment, index) {
                    if (!comment || !comment.text.trim()) { alert("„Ç≥„É°„É≥„ÉàÊú¨Êñá„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); return; }
                    
                    const originalTimestamp = comment.timestamp;
                    const newText = comment.text.trim();

                    this.$set(this.editingCard.comments[index], 'text', newText);
                    this.$set(this.editingCard.comments[index], 'isEditing', false);
                    delete this.editingCard.comments[index].originalText;
                    this.$set(this.editingCard, 'updatedAt', new Date().toISOString()); // „É¢„Éº„ÉÄ„É´ÂÜÖ„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞

                    if (!this.isEditingMode && !this.isNewCard) {
                         const { currentListId, id: cardId } = this.editingCard;
                         if (!currentListId || !cardId) return;
                         const listIndex = this.tasks.findIndex(l => l.id === currentListId); if (listIndex === -1) return;
                         const cardIndexInList = this.tasks[listIndex].cards.findIndex(c => c.id === cardId); if (cardIndexInList === -1) return;
                         
                         const targetCard = this.tasks[listIndex].cards[cardIndexInList];
                         const commentIndexInCard = targetCard.comments.findIndex(c => c.timestamp === originalTimestamp);

                         if (commentIndexInCard !== -1) {
                            this.$set(targetCard.comments[commentIndexInCard], 'text', newText);
                            this.$set(targetCard, 'updatedAt', new Date().toISOString()); // ÂÆü„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞
                            this.markDataChanged();
                         }
                    }
                },
                cancelCommentEdit(comment) {
                    if (typeof comment.originalText === 'string') { comment.text = comment.originalText; }
                    this.$set(comment, 'isEditing', false);
                    delete comment.originalText;
                },
                confirmDeleteComment(index) { if (confirm("„Åì„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ")) { this.deleteComment(index); } },
                deleteComment(index) {
                    if (!this.editingCard?.comments?.[index]) { console.error("„Ç≥„É°„É≥„ÉàÂâäÈô§„Ç®„É©„Éº", index); return; }
                    
                    const deletedCommentTimestamp = this.editingCard.comments[index].timestamp;

                    this.editingCard.comments.splice(index, 1);
                    this.$set(this.editingCard, 'updatedAt', new Date().toISOString()); // „É¢„Éº„ÉÄ„É´ÂÜÖ„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞

                    if (!this.isEditingMode && !this.isNewCard) {
                        const { currentListId, id: cardId } = this.editingCard;
                        if (!currentListId || !cardId) return;
                        const listIndex = this.tasks.findIndex(l => l.id === currentListId); if (listIndex === -1) return;
                        const cardIndexInList = this.tasks[listIndex].cards.findIndex(c => c.id === cardId); if (cardIndexInList === -1) return;
                        
                        const targetCard = this.tasks[listIndex].cards[cardIndexInList];
                        const commentIndexInCard = targetCard.comments.findIndex(c => c.timestamp === deletedCommentTimestamp);

                        if (commentIndexInCard !== -1) {
                            targetCard.comments.splice(commentIndexInCard, 1);
                            this.$set(targetCard, 'updatedAt', new Date().toISOString()); // ÂÆü„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞
                            this.markDataChanged();
                        }
                    }
                },
                updateAvailableLabels() {
                    const allLabels = new Set();
                    this.tasks.forEach(list => {
                        list.cards.forEach(card => { if (Array.isArray(card.labels)) { card.labels.forEach(label => allLabels.add(label)); } });
                    });
                    this.availableLabels = Array.from(allLabels).sort();
                    this.labelColorCache = {};
                },
                addLabelToCard() {
                    if (!this.editingCard || !this.newLabelInput.trim()) return;
                    const newLabel = this.newLabelInput.trim();
                    if (!Array.isArray(this.editingCard.labels)) { this.$set(this.editingCard, 'labels', []); }
                    const labelExists = this.editingCard.labels.some(l => l.toLowerCase() === newLabel.toLowerCase());
                    if (!labelExists) {
                        const existingLabel = this.availableLabels.find(l => l.toLowerCase() === newLabel.toLowerCase());
                        const labelToAdd = existingLabel || newLabel;
                        this.editingCard.labels.push(labelToAdd);
                        this.editingCard.labels.sort();
                        if (!existingLabel) { this.availableLabels.push(labelToAdd); this.availableLabels.sort(); }
                    } else { alert(`„É©„Éô„É´„Äå${newLabel}„Äç„ÅØÊó¢„Å´ËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`); }
                    this.newLabelInput = '';
                },
                addExistingLabel(label) { this.newLabelInput = label; this.addLabelToCard(); },
                removeLabelFromCard(index) { if (this.editingCard?.labels && index >= 0 && index < this.editingCard.labels.length) { this.editingCard.labels.splice(index, 1); } },
                getLabelColor(label) {
                    if (this.labelColorCache[label]) { return this.labelColorCache[label]; }
                    let hash = 0;
                    for (let i = 0; i < label.length; i++) { hash = label.charCodeAt(i) + ((hash << 5) - hash); hash = hash & hash; }
                    const hue = Math.abs(hash % 360);
                    const color = `hsl(${hue}, 70%, 80%)`;
                    this.labelColorCache[label] = color;
                    return color;
                },
                getCardBackgroundColor(colorId) {
                    const color = this.availableCardColors.find(c => c.id === colorId);
                    const defaultColorCode = this.availableCardColors.find(c => c.id === 'gray')?.code || this.availableCardColors[0]?.code || '#fffacd';
                    return color ? color.code : defaultColorCode;
                },
                getCardColorName(colorId) {
                    const color = this.availableCardColors.find(c => c.id === colorId);
                    const defaultColorName = this.availableCardColors.find(c => c.id === 'gray')?.name || this.availableCardColors[0]?.name || '„Éá„Éï„Ç©„É´„Éà';
                    return color ? color.name : defaultColorName;
                },
                changeCardColorImmediately(newColorId) {
                    if (!this.editingCard || this.isEditingMode || this.isNewCard) { return; }
                    if (this.editingCard.color === newColorId) { return; }
                    
                    const cardId = this.editingCard.id;
                    const listId = this.editingCard.currentListId;
                    
                    this.editingCard.color = newColorId;
                    this.$set(this.editingCard, 'updatedAt', new Date().toISOString()); // „É¢„Éº„ÉÄ„É´ÂÜÖ„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞

                    const listIndex = this.tasks.findIndex(l => l.id === listId);
                    if (listIndex !== -1) {
                        const cardIndex = this.tasks[listIndex].cards.findIndex(c => c.id === cardId);
                        if (cardIndex !== -1) {
                            this.$set(this.tasks[listIndex].cards[cardIndex], 'color', newColorId);
                            this.$set(this.tasks[listIndex].cards[cardIndex], 'updatedAt', new Date().toISOString()); // ÂÆü„Éá„Éº„Çø„ÅÆ updatedAt Êõ¥Êñ∞
                            this.markDataChanged();
                        } else { console.error("Ëâ≤Â§âÊõ¥„Ç®„É©„Éº: „Ç´„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", listId, cardId); alert("„Ç´„Éº„Éâ„ÅÆËâ≤„ÅÆÂ§âÊõ¥‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"); }
                    } else { console.error("Ëâ≤Â§âÊõ¥„Ç®„É©„Éº: „É™„Çπ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", listId); alert("„Ç´„Éº„Éâ„ÅÆËâ≤„ÅÆÂ§âÊõ¥‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"); }
                }
            },
            watch: {
                tasks: {
                    handler(newTasks, oldTasks) { if (!this.isLoading && !this._isInternalChange) { this.markDataChanged(); } },
                    deep: true
                },
                boardTitle(newValue, oldValue) { if (!this._isInternalChange && !this.isEditingBoardTitle && newValue !== oldValue) { this.markDataChanged(); } }
            }
        });
    </script>
</body>
</html>
